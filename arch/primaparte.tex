\documentclass[arch.tex]{subfiles} 

\begin{document}
\chapter{Prima Parte}

\section{Rappresentazione dei numeri}

I numeri possono essere rappresentati in qualsiasi base, noi utilizziamo la base
10 come conseguenza del numero delle nostre dita.\\
I \bt{calcolatori} utilizzano la base 2, ovvero il binario, che può facilmente
essere ricondotta alla condizione di uno stato elettrico
o \bt{positivo (1)} o \bt{negativo (0)}\\
Per la rappresentazione di un numero in qualsiasi base:
\begin{defn}
La sequenza di $k$ cifre:

\begin{equation}
	d_k \cdot d_{k-1} \cdot \dots \cdot d_1 \cdot d_0
\end{equation}
E questa sequenza la moltiplichiamo per la base scelta:

\begin{equation}
	d_k \times b^k \cdot d_{k-1} \times b^{k-1} \cdot 
	\dots \cdot d_1 \times b^1 \cdot d_0 \times b^0
\end{equation}
dove \bt{b} è la base da noi scelta.
\end{defn}

\begin{defn}[Numero di cifre in una base N]
In una qualsiasi base $N$ il numero di cifre equivale a:


\begin{equation}
	\mbox{cifre} = N - 1, N - 2, \dots, 1, 0.
\end{equation}
\end{defn}

\subsection{Notazione}
\begin{defn}[BIT]
\bt{Bit} = binary digit, uno dei due simboli (0, 1) del sistema numerico binario.
Esso è l'unità elementare dell'informazione trattata da un elaboratore.\\
Numeri di 8, 16, 32 bit equivale in base 10 
a parlare di numeri a 3, 4, 5, ... cifre \\
\end{defn}

\begin{defn}[BYTE]
\bt{Byte} = 8 bit, è una sequenza di bit, convenzionalmente l'unità di misura
delle capacità di una memoria.\\
Può assumere $2^8 = 256 (0\ -\ 255)$ possibili valori
\end{defn}

\begin{defn}[Parola]
\bt{Word/Parola} = corrisponde a 16, 32 o 64 bit in base al tipo di IS
(Instruction Set), essa è l'unità più piccola di informazione su cui un elaboratore
può intervenire.
\end{defn}

\input{sub/byte_tab}
Convenzionalmente si utlizzano come unità di misura: 
\begin{itemize}
	\item il B(yte) per la capacità di una memoria
	\item il b(it)/s per la velocità di trasmissione di dati.
\end{itemize}

\subsection{Binario}
Con la base 2 abbiamo le cifre dallo 0 allo 1.\\
Per la definizione precedente la rappresentazione sarà:


\begin{equation}
	d_k \times 2^k \cdot d_{k-1} \times 2^{k-1} \cdot 
	\dots \cdot d_1 \times 2^1 \cdot d_0 \times 2^0
\end{equation}

\begin{defn}[Valore minimo e massimo]
Il valore minmo e massimo di un numero di $n$ cifre è:	
	\begin{itemize}
		\item \bt{Valore minimo} = $ 000000\dots00(n\ \mbox{times}) = 0$
		\item \bt{Valore massimo} =$ 111111\dots11(n\ \mbox{times}) = 2^n-1$
		
		\begin{equation}
			2^{n-1} + 2^{n-2} + \dots + 2^2 + 2^1 + 2^0 = 2^n -1
		\end{equation}
	\end{itemize}
\end{defn}

\begin{esem}


\begin{equation} 
	n = 3 \implies 111 = 2^2 + 2^1 + 2^0 = 7 = 2^3 - 1 = 8 - 1
\end{equation}
\end{esem}

\subsection{Decimale}
Nella rappresentazione decimale abbiamo le cifre dallo 0 al 9.\\
Un qualsiasi numero in base decimale si può rappresentare come:


\begin{equation}
	d_k \times 10^k \cdot d_{k-1} \times 10^{k-1} \cdot 
	\dots \cdot d_1 \times 10^1 \cdot d_0 \times 10^0
\end{equation}


	\input{sub/dec_tab}

\subsection{Ottale}
Nella rappresentazione ottale si hanno le cifre dallo 0 al 7.\\
Questa base viene utilizzata perchè essendo un multiplo di 2 si possono facilmente
convertire numeri ottali in binario:\\
Con 3 cifre si possono rappresentare 8 bit.
In questo modo si possono avere numeri più facilmente maneggiabili da umani,
rispetto a lunge stringhe di 0 o 1.

\input{sub/oct_tab}
\subsection{Esadecimale}

Nella rappresentazione esadecimale si hanno 15 cifre: dallo 0, ..., 9, A, ..., F.\\
Un simbolo (cifra) in questa base rappresenta 4 cifre binarie (4 bit).\\
Con 4 cifre esadecimali si possono rappresentare 16 bit.

\input{sub/hex_tab}
\subsection{Algebra di Boole}
Essa viene utillizzata per la specifica di funzioni logiche.\\
Una qualsiasi variabile può assumere 2 valori:
\bt{vero} o \bt{falso}

\begin{defn}[Operazoini logiche di base]
	\begin{equation}
	\begin{aligned}
		A\ AND\ B\ &=\ A \cdot B\\
		A\ OR\ B\ &=\ A + B\\
		NOT\ A\ &=\ \ol{A}
	\end{aligned}
	\end{equation}
	\input{sub/log_tab}
\end{defn}
Si indica con: $\oplus = xor$, è l'or esclusivo, esso è vero solo quando una delle due variabili
è vera, non quando lo sono entrambe.\\
$\ol{A \cdot B} = nand$, l'opposto dell'AND classico\\
Grazie a XOR e NAND si possono rappresentare tutte le altre funzioni logiche
attraverso delle combinazioni di questi due.

\input{sub/bool_tab}

%TODO Boolean postulates and identitities.


\section{APPROACH}
There's a difference between \\
\bt{Computer architecture} and 
\bt{Computer organization}.

\begin{itemize}
	\item C.Architecture = attributes of a system visible to a programmer. \\
		\bt{ISA} = Instruction set architecture, is a synonym of C.A.
	\item C.Organization = operational units and their interconnections 
		that realize the architectural specifications. Examples:
		\begin{itemize}
		\item instruction set
		\item number of bits used to represent various data types
		\item I/O mechanisms and techniques for adressing memory
		\end{itemize}
\end{itemize} 

\subsection{Structure and function}
A modern computer is a hierarchical system, and is a set of interrelated subsytems.
These have, in turn, subsystems of their own until we reach the lowest level
of subsystems.
There's a huge difference between:

\begin{itemize}
	\item \bt{structure} the way components are interrelated
	\item \bt{function} the operation of each individual 
\end{itemize}
The way that is considered most efficient and the clearest approach
for describing pc components is:\bt{TOP-DOWN}

\section{ Componenti principali}
Le componenti principali di un elaboratore sono:

\begin{itemize}
	\item CPU
	\item Memoria
	\item Sistemi di I/O
	\item Interconnessioni (system bus)
\end{itemize}

\begin{center}
\begin{smartdiagram}[constellation diagram]
	{System Bus, Cpu, Memoria, Sistemi di I/O}
\end{smartdiagram}
\end{center}

\begin{defn}[Architettura di Von Neumann] 
Secondo questo tipo di architettura, un elaboratore è composto di questi
principali componenti:
\begin{itemize}
	\item dati e istruzioni in memoria
	\item memoria accessibile per indirizzo
	\item esecuzione sequenziale delle istruzioni
\end{itemize}
\end{defn}

\begin{defn}[Programma cablato]
	Consiste nel costruire i componenti logici in modo tale che il risultato 
	sia quello voluto e non può essere modificato in seguito.\\
	Vuol dire "programmare" a livello hardware, ovvero con le 
	componenti fisiche.\\
	Non è un sistema flessibile, esegue solo operazioni predeterminate.
\end{defn}

\begin{defn}[Programma]
	Un programma è una sequenza di passi\\
	Ogni passo corrsiponde ad un'operazionie logica.\\
	Ogni operazione determina un diverso insieme di segnali di controllo.
\end{defn}

\begin{defn}[Programmazione software]
	Nasce con Von Neumann, si parte da un hardware generico, 
	si ha una parte che preleva il codice di una istruzione, è generale:
	L'hardware di cui parliamo si dice \bt{general purpose}, utile a vari scopi.
	Si hanno poi dei segnali di controllo corrispondenti.\\
	Questo sistema è molto più flessibile di quello "cablato".\\
	La CPU assume delle funzioni diverse ovvero:
	
	\begin{itemize}
	\item interprete delle istruzioni
	\item generico modulo per operazioni aritmetico logiche = ALU
	\end{itemize}
	I segnali di controllo sono necessari per far eseguire 
	al giusto modulo la giusta operazione: ALU\\
	ALU prende segnali di controllo ed esegue le istruzioni codificate\\
	In questo sistema si ha la codifica 
	delle istruzioni e la decodifica delle istruzioni.

\end{defn}



\begin{defn}[Memoria principale nell'architettura di Von Neumann]
Si ha la possibilità di salti oltre che all'esecuzione sequenziale(in serie)\\
Per esempio con le operazioni che richiedono accesso a più dati in memoria
nello stesso momento.\\
Inoltre essa ha il compito di immaggazzinare dati e istruzioni
\end{defn}

\begin{esem}
Somma con 2 numeri in locazione di memoria diverse
\end{esem}

\section{CPU}
Essa non deve solo eseguire istruzioni ma anche gestire dei segnali di controllo e 
getstire delle risorse.\\
Composta da Vari componenti principali:

\begin{itemize}
\item \bt{EU} = execution unit = alu

\item \bt{IR} = instruction register, registro che 
	contiene l'istruziuone da eseguire successivamente a quella nel PC.
\item \bt{PC} = program counter, puntatore all'istruzione 
	indirizzo dell'istruzione da eseguire presente nella memoria.
\item \bt{MAR} = memory address register, registro di interfaccia con 
	il bus di sistema, contiene solo registri
\item \bt{MBR} = memory buffer register, contiene solo dati.\\
Il MAR e il MBR mantengono le infromazioni fino a che non è 
disponibile il bus di sistema per essere impiegato.

	\begin{itemize}
		\item in caso di lettura raccolgono il dato dal bus.
		\item in caso di scrittura contengono il dato.
	\end{itemize}
\item \bt{I/O AR} indirizzo periferica con cui scambiare dati, 
	specificare periferica 
\item \bt{I/O BR} raccolta dati 
\end{itemize}
Quando si ha un salto nell'esecuzione delle 
istruzioni incrementa l'indirizzo del PC\\
Inoltre è presente un buffer nel modulo I/O: è una memoria interna al sistema di 
input output, esso serve perchè la CPU invia dati troppo velocemente rispetto 
ed esso non può riceverli alla stessa velocità, per questo 
il buffer dell'I/O, mantiene in memoria i dati inviati dalla più veloce CPU 
\subsection{Funzionamento CPU}
\begin{itemize}
	\item \bt{Fetch}: reperimento, prelievo dell'istruzione dalla memoria
	\item \bt{Execute}: esecuzione dell'istruzione prelevata dalla memoria
\end{itemize}

\begin{center}
\begin{smartdiagram}[flow diagram:horizontal]{Start, Fetch, Execute}
\end{smartdiagram}
\end{center}
Il registro \bt{PC} contiene l'indirizzo di memoria della
cella di Memoria contenente l'istruzione da eseguire.
Quando si ha un prelievo di istruzioni dalla memoria, si ha un incremento del PC.\\
L'istruzione prelevata viene messa in IR poi viene eseguita.


\subsection{Tipi di Operazioni}

\begin{enumerate}
	\item Processore-memoria: trasferimento dati dalla CPU alla Memoria R/W
	\item Processore-I/O: trasferimento dati da CPU a I/O               R/W
	\item Elaborazione dati: operazioni logiche e aritmetiche sui dati
		operazioni della ALU
	\item Controllo: può alterare la sequenza delle istruzioni, per esempio
		il salto
\end{enumerate}

\begin{esem}	
Parola = 16bit\\
Istruzione = 16bit\\
Codici operativi = 4 bit a sinistra = $2^4$ combinazioni = 16

\begin{itemize}
	\item 0001 carica in AC (accumulatore) una cella di M
	\item 0010 scrive in M il contenuto di AC
	\item 0101 somma una cella di M ad AC
\end{itemize}
\end{esem}

\subsection{Ciclo di esecuzione}

\begin{enumerate}
	\item Instruction Address Calculation
	\item Instruction Fetch
	\item Instruction operation decoding
	\item Operand address calculation
	\item Operand Fetch
	\item Data operation
	\item Operand address calculation 
	\item Operand Store
\end{enumerate}

\newpage

\begin{center}
    \smartdiagramset{
        uniform color list=white!60!black for 6 items,
        back arrow disabled=true,
        module minimum width=2cm,
        module minimum height=2cm,
        module x sep=4cm,
        text width=3cm,
        additions={
            additional item offset=20mm,
            additional item width=2cm,
            additional item height=2cm,
            additional item text width=3cm,
            additional item shadow=drop shadow,
            additional item bottom color=white!60!black,
            additional item border color=gray,
            additional arrow color=gray,
        }}
        \smartdiagramadd[flow diagram:horizontal]{
            Instruction Address\\ Calculation, Instruction Fetch, 
	    Instruction operation decoding, Operand address\\ calculation}
	    {
        below of module1/Operand Fetch,
	below of module2/Data Operation,
	below of module3/Operand Address Calculation,
	below of module4/Operand Store}
    \smartdiagramconnect{->}{additional-module1/additional-module2,
    additional-module3/additional-module4}
    \begin{tikzpicture}[remember picture,overlay]% modified from p. 47 of manual
    \draw[additional item arrow type] (module4) |- ([yshift=-10mm]module1.south) -- (additional-module1);
    \end{tikzpicture}
    \vspace{40mm}\par

\end{center}






Per l'esecuzione di una singola operazione, bisogna prima eseguire una serie
di altri sottocompiti, che devono essere ben eseguiti. \\
Per questo è essenziale \bt{l'unità di controllo}, per accertarsi che
ogni operazione venga eseguita correttamente e nel giusto ordine.\\
La CPU può eseguire \bt{più operazioni} momentaneamente, mantenendo ogni sua parte attiva
, breve introduzione al concetto di pipeline


\subsection{Interruzioni}
Il meccansimo tramite il quale dei moduli possono interrompere la normale di sequenza di esecuzione. \newline
Il ciclo di esecuzione con interruzioni è differente: al \bt{termine}
di un ciclo si ha il controllo delle interruzioni,

\begin{itemize}
	\item se ce ne sono, esse vengono risolte
	\item se non ce ne sono, il ciclo ricomincia
\end{itemize}

Tipi di interruzioni:
\begin{itemize}
	\item Program, overflow, divisione per zero
	\item Timer, da un timer inerno alla CPU
	\item I/O, termine di un'operazione di I/O
	\item Guasto Hardware
	\end{itemize}
Si interrompe per
\begin{itemize}
	\item efficienza elaborazione
\end{itemize}

Ciclo interruzione:
\begin{itemize}
	\item viene aggiunto al ciclo di esecuzione
	\item la cpu controlla (fetch) le interruzioni pendenti
	\item se non ce ne sono, prende la prossima istruzione
	\item se ce ne sono: 
	\begin{itemize}
		\item sospende esecuzione
		\item salva contesto
		\item imposta il pc all'indirizzo di inizio del 
			programma di gestione
		\item esegue il programma di gestione dell'hardware
		\item rimette il contesto al suo posto e continua 
			il programma interrotto
	\end{itemize}
\end{itemize}
Lunghezza di attesa:

\begin{itemize}
	\item \bt{breve attesa}, tempo di operazione di I/O minore del
		tempo tra due istruzione WRITE
	\item \bt{lunga attesa}, 
\end{itemize}

\subsubsection{Interruzioni multiple}
In caso di \bt{interruzioni multiple}: esistono vari livelli di interruzione e 
differenti tipi di politica di gestione.\\
Esistono interruzioni di alto livello e basso livello, a seconda dell'importanza
che hanno per il funzionamento del sistema.\\
\bt{Politiche di interruzione}:

\begin{itemize}
	\item Disabilitare le interruzioni:
		\begin{itemize}
			\item La CPU \bt{ignora} le altre interruzioni e
				gestisce la prima e "maschera" le altre
			\item Le interruzioni rimangono \bt{pendenti}
			\item vengono gestite nell'\bt{ordine} in cui arrivano
		\end{itemize}
	\item Definire le priorità
		\begin{itemize}
			\item Interruzioni di bassa priorità vengono
				interrotte quando si presentano quelle di 
				alta priorità
			\item Quando è stata gestita la priorità di 
				alto livello viene maneggiata
				quella di basso livello
			\item Si hanno delle interruzioni \bt{annidate}
		\end{itemize}
\end{itemize}

\section{Interconnessioni}
Tutti i componenti \textbf{devono} essere connessi \newline
Esistono vari tipi di connessioni per vari tipi di componenti, il bus collega:
\begin{itemize}
	\item CPU
	\item Memoria 
	\item I/O
\end{itemize}
Composto da 50 a qualche centinaio di linee
\subsection{Bus}
Tutti i dispostivi sono collegati dal bus di sistema \newline
Il bus:
\begin{enumerate}
	\item collega \textbf{2 o più} dispositivi
	\item mezzo trasmissione condiviso
	\item un segnale trasmesso ad un bus è disponibile a tutti i dispositivi
	\item arbitro bus: solo un dispostivo alla volta può trasmettere
	\item varie linee di comunicazione ( trasmettono uno 0 o un 1)
	\item varie linee trasmettono in parallelo numeri binari. 
		Un bus da 8 bit trasmette un dato di 8 bit
\end{enumerate}
Solitamente l'ampiezza del bus corrisponde ad un multiplo della parola.\\
Tipi di bus:

\begin{enumerate}

\item Bus di sistema:
\begin{itemize}
	\item connette cpu, i/o, M
	\item da 50 a qualche centinaio di linee
	\item 3 gruppi di linee
	\begin{enumerate}
		\item bus dati
		\item indirizzi
		\item controllo
	\end{enumerate}
\end{itemize}

\item Bus dati:
\begin{itemize}
	\item trasporta dati o istruzioni
	\item ampiezza --$ > $ efficienza  del sistema
	\begin{itemize}
		\item con poche linee --$>$ maggiori accessi in memoria
	\end{itemize}
\end{itemize}

\item Bus indirizzi:
\begin{itemize}
	\item indica sorgente o destinazione dati
	\item l'ampiezza determina la massima quantità di M indirizzabile
	\begin{esem}
	Architettura a 64 bit = $ 2^{64} - 1 $ indirizzi\\
	Il bus deve essere di almeno 64 bit.
	\end{esem}
	\item deve essere di almeno 1 parola
\end{itemize}

\item Bus controllo:\\
Per controllare accesso e uso di:

\begin{itemize}
	\item \bt{linee dati}
	\item \bt{indirizzi}
	\begin{enumerate}
		\item M write
		\item M read
		\item richiesta bus
		\item bus grant
		\item interrupt request
		\item clock
	\end{enumerate}
\end{itemize}

\end{enumerate}

\subsection{Uso del bus}
Con modulo intendiamo una generica componente del computer.\\
se un modulo vuole inviare dati ad un altro:
\begin{itemize}
	\item bus grant
	\item data transfer
\end{itemize}
se un module vuole ricevere dati da un altro:
\begin{itemize}
	\item bus grant
	\item trasferire una richiesta all'altro modulo sulle linee di controllo 
	\item attendere invio dati
\end{itemize}


\subsection{Bus singoli e multipli}
\begin{itemize}
	\item singolo bus = ritardo e congestione
	\item vari bus = risoluzione problema
\end{itemize}
Esempio di Bus multiplo:

\begin{itemize}
	\item \bt{connessione punto a punto} fra CPU e cache, il che rende
	il trasferimento dei dati molto più veloce ed efficiente.
	\item \bt{Bus di espansione},	si interfaccia con i dispositivi I/O
	\item \bt{Bus ad alta velocità}, si interfaccia con i dispositivi I/O
		e fornisce una trasmissione di dati più rapida 
	\item \bt{Bus di sistema}, fra cache e Memoria principale.
\end{itemize}



\subsection{Temporizzazione}
Coordinazione degli eventi su un bus
\begin{itemize}
	\item Asincrona
		\begin{itemize}
		\item più complessa da implementare
		\end{itemize}
	\item Sincrona
	\begin{itemize}
		\item clock determined events
		\item single clock line, with an alternate sequence of 0 and 1,
			with equal length
		\item single 1-0 sequence is a clock cicle
		\item every device connected to the bus can read the clock line
		\item every event starts at the beginning of a clock cycle
	\end{itemize}
\end{itemize}

\subsubsection{QPI}
\bt{Interconnessione Punto a Punto}, con l'aumentare della velocità dei 
processori è sempre più frequenta una distribuzione di dati densa e veloce.\\
Un bus condiviso però rallenta la comunicazione del processore (bottleneck)
, per questo si adottano delle connessioni punto a punto.

\begin{itemize}
	\item Connessioni dirette multiple:\\
		più componenti del sistema godono di connessioni dirette a 
		coppie con altri componenti.
	\item Architettura di protocollo a strati
	\item Trassferimento Dati a pacchetto:\\
		i dati non sono inviati come flussi di dati non elaborato
		ma come una sequenza di pacchetti, essi includono intestazioni 
		di controllo e codici di correzione dell'errore.
\end{itemize}
Livelli di QPI:

\begin{itemize}
	\item \bt{fisico}\\
		la parte hardware, l'unità di trasferimento è di 20 bit (Phit)
		, tutto è sincronizzato da un clock.
	\item \bt{Link}\\
		trasmissione affidabile del controllo del flusso,
		l'unità di trasferimento è di 80 bit (Flit).\\
		Protocollo con pacchetti da 72 (dati) + 8 (codice
		di correzione errore) bit.
		\begin{itemize}
			\item Controllo del flusso:\\
				il mittente non può inviare più dati di quelli
				che il destinatario può ricevere.
			\item Controllo dell'erroreç
				8 bit per rilevare errori di trasmissione 
				sugli altri 72 bit.\\
				In caso di errore il mittente deve re-inviare
				il pacchetto errato.
		\end{itemize}
	\item \bt{Routing}\\
		Struttura per dirigere i pacchetti attraverso essa. Determina il
		percorso che un pacchetto deve seguire.\\
		Supportato da tabelle di instradamento:
		\begin{itemize}
			\item definite da software di basso livello che
				contiene delle istruzioni
			\item descrizione percorso che un pacchetto può seguire
			\item utile in sistemi di maggiori dimensione
		\end{itemize}
	\item \bt{Protocollo}\\
		Insieme di regole ad alto livello per lo scambio di pacchetti.
		Un pacchetto è un numero intero di Flits. Il contenuto di 
		un pacchetto è flessibile, per gestire esigenze diverse.\\
		Supporta il protocollo di coerenza della cache, per garantire 
		coerenza fra i contenuti della cache dei core e la memoria 
		principale
\end{itemize}


\section{Memorie}
Caratteristiche principali della memoria:

\begin{itemize}
	\item Locazione: processore (cache), interna 
		(principale RAM), esterna (secondaria)
	\item Capacità: dimensione parola (dipende dall
		'architettura), numero di parole
	\item Unità di trasferimento: parola, fra cache e RAM in blocco ( 
		insieme contiguo di parole)
	\item Metodo di accesso:
		\begin{itemize}
			\item sequenziale: accedere prima a tutte le informazioni
				che vengono prima: lento. Utilizzato nei nastri
				magnetici, backup sistemi.
			\item diretto, organizzata in gruppi,
				accesso sequenziale ai gruppi. accesso diretto 
				ad un insieme di informazioni. HDD
			\item casuale, accesso diretto a quella locazione
				di memoria, non importa dove si trova la 
				locazione di memoria dell'informazione. RAM
			\item associativo, informazione non indviduata da 
				indirizzo, ma da una parte dell'informazione.
				CACHE
		\end{itemize}
	\item Prestazioni: tempo di accesso, ciclo e velocità di trasferimento
	\item Modello fisico:
		\begin{itemize}
			\item semiconduttore (ROM)
			\item magnetico, campi magnetici (HDD)
			\item ottico, laser ottico (CD)
			\item magnetico-ottico
		\end{itemize}
	\item Caratteristiche fisiche:
		\begin{itemize}
			\item volatile (cache, quando termina il flusso di 
				corrente elettrica i dati vengono cancellati)
			\item non volatile (hdd, i dati vegnono memorizzati
				permanentemente quando si spegne il computer)
			\item riscrivibile (RAM, HDD, cache)
			\item non riscrivibile (ROM, read only memory).
		\end{itemize}
	\item Organizzazione, se suddivisa in un singolo chip oppure vari,
		più o meno moduli.
\end{itemize}
Generalmente all'aumentare del costo della memoria aumenta la sua
velocità ma diminuisce la sua ampiezza.\\
In ordine decrescente per velocità, costo e crescente per ampiezza:

\begin{itemize}
	\item Registro (1 parola) 16 - 64 bit
	\item Cache (1 indirizzo)
	\item SRAM
	\item DRAM (8gb - 64gb)
	\item SSD (1TB - 8TB)
	\item HDD (16TB-24TB)
	\item CD - DVD-ROM
	\item Nastro (vari PB)
\end{itemize}
L'aumento di prestazioni delle CPU si deve a migliorie tecnologiche e architetturali, mentre
quello delle memorie \bt{solo} ad avanzamenti tecnologici.\\
Proprieta' dei programmi: 

\begin{itemize}
	\item Statiche, dal file sorgente
	\item Dinamiche, dall'esecuzione
		\begin{itemize}
			\item Linearita' dei riferimenti, spesso consecutivi
			\item Localita' dei riferimenti, indirizzi contigui sono piu' probabili
		\end{itemize}
\end{itemize}

\begin{defn}[Congettura 90/10]
Un programma impiega di solito il 90\% del suo tempo di esecuzione alle prese 
con un numero di istruzioni pari a circa il 10\% di tutte quelle che le compongono.
\end{defn}

\subsection{Gerarchia di memoria}
Tutte le locazioni di memoria sono suddivise in blocchi. \\
Conviene organizzare la memoria in vari livelli gerarchici:

\begin{itemize}
	\item Cache la più veloce e suddivisa in diversi livelli
		\begin{itemize}
			\item L1 cache:\\
				molto veloce e molto costosa, per i dati ad accesso probabile\\
				es. 10\% di cui parlavamo prima
			\item L2 cache, più capiente ma meno veloce della L1.
			\item L3 cache, più capiente ma meno veloce della L2
		\end{itemize}
	\item Ram, più lenta della cache ma più capiente ed economica
\end{itemize}
La memoria Ram è composta da:
\begin{enumerate}
	\item indirizzo di memoria
	\item blocco di memoria 
\end{enumerate}
Memoria a livelli:
\begin{enumerate}
	\item Livello inferiore, supporti con capacità più alti, piu' lenti, meno costosi
	\item A livelli piu' alti diventano progressivamente piu' veloci, piu' costosi
		e meno capienti.
\end{enumerate}
La CPU usa il livello piu' alto. Ogni livello inferiore contiene tutti i dati presenti ai 
livelli superiori.

\subsubsection{trasferimento dati}
I dati vengono scambiati sotto forma di WORD/PAROLE:

\begin{itemize}
	\item CPU - Cache: scambio di PAROLE
	\item CACHE - MEMORIA P. scambio di BLOCCHI (multiplo di PAROLE)
\end{itemize}
La memoria lavora efficientemente se la CPU trova il dato cercato nella CACHE. Avendo 
piu' livelli di cache si ha una maggiore probabilità di trovare questo dato.\\
Il numero di parole in un blocco è una potenza di 2. \\
Una parola è composta da 4 byte, possiamo identificare i primi 14 bit come 
"indirizo" del bit, mentre i restanti 2 come identificativi del bit.

\subsection{Cache}
Un indirizzo di linea di cache e' costituito generalmente da:
\begin{enumerate}
	\item Etichetta (tag), indirizzo del blocco nella memoria principale.
	\item Blocco di $K$ parole
\end{enumerate}

Un blocco di memoria richiesto dalla CPU può essere presente \textbf{hit} o non presente \textbf{miss} in memoria. (generalmente è presente). \newline
Per guadagnare efficienza prestazionale un \bt{hit} deve essere molto probabile ($>$ 90\%), 
se fosse minore di questa percentuale non avrebbe senso utilizzare quella struttura di memoria.\\
Un \bt{miss} avvia una procedura di scambio di dati con un livello inferiore.\\ 
Una linea di cache può memorizzare diversi blocchi diversi, si usano i bit piu' a destra
per identificare la parola all'interno della linea e i bit piu' a sinistra qual'e' 
la linea di cache per identificare il blocco.

\begin{defn}[Organizzazione]
La memoria principale e' suddivisa in blocchi logici\\
La cache e' suddivisa in un multiplo di blocchi.
\end{defn}

\begin{defn}[Tempo medio di Accesso]
$T_a$: Tempo medio di accesso ad un dato in memoria cache 

\begin{equation} T_a\ =\ T_h \times P_h + T_m(1-P_h) \end{equation}
$T_h$: tempo di accesso ad un dato presnte in cache
$T_m$: tempo medio di accesso ad un dato \textbf{non} in cache (dimensione blocco)
$P_h$: probabilità di hit \\
\end{defn}
\textit{Tecnica generale} 

\begin{enumerate}
	\item Suddivisione della memoria centrale in blocchi logici
	\item dimensionamento della cache in multiplo di blocchi
	\item ogni indirizzo emesso dalla cpu
		\begin{itemize}
			\item hit $\iff$ il dato viene fornito immediatamente alla cpu,
				(sotto forma di parola)
			\item miss, il dato viene fornito sotto forma di blocco
				\begin{enumerate}
					\item la cache richiede il dato al livello inferiore
						(memoria principale RAM)
					\item viene posto in cache 
					\item viene fornito alla cpu 
				\end{enumerate}
		\end{itemize}
\end{enumerate}

\begin{defn}[\textbf{associazione diretta / direct mapping}] 
Ogni blocco del livello ineriore può essere allocato solo in una specifica posizione  \textbf{linea/slot} del livello superiore
\begin{enumerate}
	\item \textbf{ILS} = indirizzo di livello superiore
	\item \textbf{ILI} = indirizzo di livello inferiore 
	\item $ILS = ILI\ mod\ N$, divisione con resto intero
\end{enumerate}	

\begin{enumerate}
	\item vantaggi
		\begin{itemize}
			\item semplicità traduzione indirizzo ILI a ILS
			\item determinazione velocità hit o miss
		\end{itemize}
	\item svantaggi
		\begin{itemize}
			\item necessità di contraddistinguere blocco in ILS
			\item swap frequenti per accesso a dati di blocchi adiacenti,\\
				il primo blocco di ogni insieme avrà la stessa linea di cache,
				quindi solo uno di questi puo' essere in cache 
		\end{itemize}
\end{enumerate}
\end{defn}

\begin{defn}[\textbf{associazione completa / fully associative}] 
Ogni blocco del livello inferiore può essere posto in qualunque posizione del livello superiore. \newline
Ad una cache di N blocchi viene associata una tabella di N posizioni contenenti il numero di blocco effettivo (tag)
\begin{itemize}
	\item vantaggi: massima efficienza di allocazione
	\item molto tempo per la corrispondenza ILS-ILI e della verifica hit/miss
	\item molto costoso dal punto di vista hardware e scarsa possibilità di hit 
	\item difficile identificazione di hit o miss
\end{itemize}
\end{defn}

\begin{defn}[\textbf{associazinone a N-gruppi / N-way set associative}] 
Ogni blocco di un certo insieme di blocchi del livello inferiore può essere allocato liberamente in uno specifico gruppo di blocchi del livello superiore

\begin{esem}
Per una cache di 32 linee con un $N$ equivalente a 2, ogni gruppo avrà 16 linee.\\
Ci sono 16 gruppi da 2 linee e per ogni coppia avremo un blocco di una determinata posizione di
qualunque insieme.
\end{esem}
Questo tipo di associazione è una via di mezzo fra gli altri due tipi. 
La cache composta da $R$ gruppi di $N$ posizioni di blocco, si affiancano $R$
tabelle di $N$ elementi contenenti i tag.\\
Per ottenere facilmente il numero di linee basta semplicemente fare la moltiplicazione

\begin{equation}
	\mbox{Numero di linee della cache} = N \times R 
\end{equation}
Ha una buona efficienza di allocazione, nonstante abbia una certa complessità, e prende 
i due punti di forza degli altri due tipi:

\begin{itemize}
	\item uso efficiente delle linee di cache
	\item facile determinazione di hit o miss
\end{itemize}
Non e' necessario avere un grande numero di N per raggiungere il massimo dell'efficienza1

\end{defn}

\subsection{Politiche di rimpiazzo dei blocchi}
Quando si ha un miss, come si decide quale blocco della cache dobbiamo rimpiazzare?\\
Nell'associazione diretta non ci si pone questo problema, perchè ogni linea della 
cache corrisponde un blocco della memoria centrale.
\begin{enumerate}
	\item \textit{casuale}, viene occupato lo spazio omogeneamente, 
		facile implementazione
	\item \textit{First-In-First-Out(FIFO)}, il blocco rimasto più a 
		lungo in cache, complicata implementazione
	\item \textit{Least Frequently Used(LFU)}, il blocco con meno accessi, 
		complicata implementazione hardware
	\item \textit{Least Recently Used(LRU)}, il blocco con 
		l'accesso più distante,per preservare quelli accessi 
		più recentemente, implementazione difficile.
\end{enumerate}
A minor quantità di cache si hanno migliori prestazioni con il rimpiazzo LRU.\\
Questo e' il metodo piu' gettonato, e ad aumentare il livello di cache 
è sempre meno significativo il miglioramento offerto da queste tecnologie.\\
La scrittura dati determina incoerenza tra il blocco in cache e quello nei 
livelli inferiori


\begin{defn}
write through:

\begin{enumerate}
	\item scrittura contemporanea in cache e livello inferiore
	\item aumento traffico per frequenti scritture nel medesimo blocco,
		dati coerenti fra blocchi
	\item si ricorre a buffer asincroni verso la memoria, a
		causa di momenti di congestione del bus.
\end{enumerate}
\end{defn}
La memoria contiene \bt{istruzioni} e \bt{dati} e solo il 50\% delle operazioni
sui dati sono scritture.


\begin{defn}
write back:

\begin{enumerate}
	\item scrittura in memoria inferiore differita al rimpiazzo del blocco di cache corrisp.
	\item ridotto numero di modifiche nella memoria principale
	\item occore ricordare operazioni di scrittura nel blocco
	\item ottimizazione del traffico tra livelli, riduzione
		congestione bus
	\item periodi di incoerenza
\end{enumerate}
\end{defn}
Occore ricordare che tra memoria centrale (RAM) e cache si passano \textbf{BLOCCHI} e non \textbf{PAROLE}.



\begin{esem}[scenario problematico]
\begin{itemize}
	\item più dispositivi connessi allo stesso bus con cache locale
	\item memoria centrale condivisa
\end{itemize}
Nessun tipo di "write" (through, back) può assicurare coerenza.
\end{esem}
Possibili soluzioni


\begin{itemize}
	\item \textbf{monitoraggio del bus con write through}, controllori
		intercettano modifiche locazioni condivise
	\item \textbf{trasparenza hardware}, hardware aggiuntivo: modifica a RAM = modifica a cache
	\item \textbf{memoria non cacheable}, solo una porzione è condivisa e non cacheable
\end{itemize}
Cosa comporta la modifica di dati in una cache?

\begin{itemize}
	\item invalida quella parola corrispondente nella memoria centrale
	\item invalida la parola nelle altre cache che la contengono\\
		per esempio in un sistema con CPU multi-core
\end{itemize}
Estendiamo il discorso alla memoria swap e RAM:\\
Quello che cambia e' che al livello cache-RAM e' tutto basato su un livello logico,
mentre nell'altro caso si parla di un livello fisico fra RAM e memoria
swap dei dispositivi di archiviazione eseterna.\\
Le problematiche che si incontreranno saranno le stesse: capienza RAM
piena, politiche di rimpiazzo, modalita' di scrittura.\\
I blocchi diventano pagine di un programma.

\subsubsection{Cache logica e fisica}
Possiamo avere due tipi di Cache: 

\begin{itemize}
	\item Logica, riceve un indirizzo logico ma ad ogni cambiamento di contesto 
		deve essere svuotata,
		conveniente se si prevede un utilizzo in un contesto 
		con poche interruzioni
	\item Fisica, riceve un indirizzo fisico deve attendere la traduzione dell'indirizzo
		da logico a fisico, non deve essere svuotata ad ogni cambiamento di 
		contesto, conveniente in un contesto con molte interruzioni
\end{itemize}

La cache deve essere svuotata ad ogni cambiamento di contesto, altrimenti
non puo' funzionare bene.

\subsubsection{Il problema dei miss}
Esistono vari tipi di miss:

\begin{itemize}
	\item di primo accesso, inevitabile non riducibile
	\item per capacità insufficiente, quando la cache non può contenere altri blocchi
	\item per conflitto, dipende dal tipo di associazione, quando vari blocchi possono
		corrispondere allo stesso gruppo
\end{itemize}
Soluzioni classiche:

\begin{itemize}
	\item Maggior dimensione di blocco, aumento di miss, aumento linee utilizzo 
		piu' efficiente dello spazio
	\item Maggiore associativita', incremento del tempo di localizzazione di un gruppo,
		soggetto alla regoal 2:1
\end{itemize}
Altre soluzioni:

\begin{itemize}
	\item multilivello cache, fino a 3 livelli
	\item separazione cache dati / cache istruzioni
	\item ottimizazione degli accessi mediante compilatori (C)
\end{itemize}

\subsubsection{tipi di memorie a semiconduttore}
\input{sub/mem_tab}
Si dice di una memoria che e' volatile o no quando: se manca l'alimentazione
l'intero contenuto della memoria si cancella. 

\begin{defn}[DRAM]
Dynamic RAM =

\begin{itemize}
	\item bit memorizzati in condensatori
	\item decadimento cariche con tempo
	\item refresh cariche, durante alimentazione
	\item semplice costruzione
	\item 1 condensatore = 1 bit
	\item meno costose
	\item circuito per refresh
	\item meno veloci della SRAM
	\item usate nella RAM
	\item operazione analogica, la carica determina il valore (0 o 1)
\end{itemize}
\end{defn}

\begin{defn}[SRAM]
Static RAM =

\begin{itemize}
	\item bit memorizzati tramite porte logiche
	\item non perde la carica
	\item no refresh
	\item piu' complesso, piu' elementi per bit (6 transistor)
	\item piu' costosa
	\item no refresh
	\item piu' veloce, utilizzata nella cache
	\item digitale
\end{itemize}
\end{defn}

\subsection{ROM}
Una ROM: 

\begin{itemize}
	\item memorizzazione permanente ( non volatile )
	\item memorizzano:
		\begin{itemize}
			\item microprogrammi
			\item subroutine di libreria
			\item programmi di sistema
			\item funzioni tabulate (logaritmi, esponenziali, etc)
		\end{itemize}
\end{itemize}

\subsection{Codice correzione errore}
Tipi di errori: 

\begin{itemize}
	\item Guasto hardware, non risolvibile
	\item errore software, possono accadere casualmente, a causa del decadimento
		della materia, i danni non sono permanenti
\end{itemize}
Quando un errore viene rilevato, puo' essere corretto attraverso
i codici di Hamming (quelli che vedremo)\\
Quando un dato viene creato assieme ad esso si crea una sua 'impronta digitale'
che verra' utilizzata per comparare la validita' del dato.\\
Si trasmettono gli 'M' bit di dati assieme a dei 'k' bit generati da una 
certa funzione che creano una sorta d'impronta digitale.\\	
Attraverso la funzione che converte gli 'M' bit nei 'k' bit si utilizza per 
ricostruire il dato originale e confrontarlo con l'originale o lo si utilizza per 
correggerlo.\\
Questo tipo di codice di correzione è valido quando c'è un solo errore.\\
La formula per determinare la quantità di bit di correzione necessari:

\begin{equation}
	2^{k-1} \geq M + K
\end{equation}
Questa quantità diminuisce drasticamente all'aumentare degli 'M' bit:

\input{sub/cod_tab}

Quando ci sono 2 errori si riesce a corregerne uno solo e si comunica che 
è stato rilevato un errore ma non è correggibile.

\subsection{Memorie esterne}
Le memorie esterne si suddividono in 4 macro-categorie:

\begin{itemize}
	\item dischi magnetici
		\begin{itemize}
			\item RAID
			\item rimovibili
		\end{itemize}
	\item dischi SSD
	\item ottica
		\begin{itemize}
			\item CD-ROM
			\item CD-Recordable (CD-R)
			\item CD-R/W
			\item DVD
		\end{itemize}
	\item nastri magnetici
\end{itemize}

\subsubsection{Dischi magnetici}
I dischi sono ricoperti di materiali magnetici, e le informazioni è
memorizzata in un campo \bt{magnetico}.\\
Venivano costruiti in alluminio, mentre ora si utilizza il vetro perchè

\begin{itemize}
	\item la sua superficie è più uniforme,
		(lo rende più affidabile), 
	\item ci sono meno difetti di superficie 
		(e ne riduce gli errori), 
	\item è più rigido
	\item la testina può essere posta più vicino al disco
	\item è più resistente.
\end{itemize}
Il disco è organizzato in \bt{cerchi concentrici} di informazione
(chiamati tracce), il disco ruota e la \bt{testina} viene spostata in 
senso radiale verso l'interno o l'esterno del disco.\\ 
Può leggere o scrivere rilevando \bt{campi magnetici} o inducendoli. 
L'orientamento di un campo magnetico si determina in base al 
verso con cui la corrente scorre e determina il tipo di informazione che
viene passata. Dato che i campi magnetici rimangono impressi nel 
materiale ferroso (ossido di ferro) è un dispositivo \bt{non-volatile}.\\
L'interferenza fra campi magnetici è divisa fra le tracce da dei gap.\\
I dati vengono memorizzati tramite una bobina conduttiva di 
scrittura detta \bt{testina}.\\
I dati sono memorizzati in anelli o \bt{tracce concentriche}. I dischi ruotano ad 
una \bt{velocità angolare costante}, ciò vuol dire che le tracce più
interne a parità di rotazione perccoronon meno 
strada rispetto alle tracce più esterne.\\
Una conseguenza di questo fenomeno e del fatto che le informazioni
contenute in ogni traccia devono essere della stessa quantità di byte,
implica che i campi magnetici delle tracce più
interne sarannno necessariamente più compatti. La densità delle tracce 
non è consistente.\\
Le tracce si dividono in:

\begin{itemize}
	\item Settori, la dimensione minima di un blocco coincide 
		con un settore
	\item Più di un settore per blocco
	\item Con più dischi, le tracce nella stessa posizione costituiscono
		un cilindro
\end{itemize}
Per \bt{ricercare un settore} bisogna riconoscere l'inizio della traccia e 
del settore. Testina sulla traccia e attendere che il settore d'interesse passi
attraverso la testina. (es. treno: quando prendiamo un treno ci sono 3 scenari:
il treno sta per partire, dobbiamo aspettare un po', oppure il treno
è già partito e dobbiamo aspettare il prossimo. Si può fare un'analogia
con la testina (noi) settore (treno)).
Il \bt{formato di un disco} è:

\begin{itemize}
	\item Informazioni aggiuntive non disponibili all'end user
	\item demarca tracce e settori
\end{itemize}

\begin{esem}[Disco Winchester]
In esso si possono ottimizzare la distanza fra traccia e testina.\\
In particolare un settore di questo formato è composto da 600B:

\begin{itemize}
	\item GAP 1 = 17B
	\item Campo ID = 7B
		\begin{itemize}
			\item Byte di sincronizzazione = 1B
			\item N° traccia = 2B
			\item N° testina = 1B
			\item N° settore = 1B
			\item Codice correzione errore = 2B
		\end{itemize}
	\item GAP 2 = 41B
	\item Campo dati = 515B
		\begin{itemize}
			\item Byte sincronizzazione = 1B
			\item Dati = 512B
			\item Codice correzione errore = 2B
		\end{itemize}
	\item GAP 3 = 20B
\end{itemize}

\end{esem}
Caratteristiche di un dispositivo di memorizzazione esterna:

\begin{itemize}
	\item Testina
	\begin{itemize}
		\item Fissa (raro)
		\item mobile
	\end{itemize}
	\item Disco
	\begin{itemize}
		\item Rimovibile
		\item Fisso
	\end{itemize}
	\item Fascia
	\begin{itemize}
		\item singola
		\item doppia
	\end{itemize}
	\item Piatto
	\begin{itemize}
		\item singolo
		\item doppio
	\end{itemize}
	\item Meccanismo della testina:
		\begin{itemize}
			\item contatto (floppy)
			\item distanza fissa
			\item seprazione aerodinamica
			\begin{itemize}
				\item Testine foil planano sulla superificie 
					dei dischi sfruttando la portanza 
					del profilo
				\item Testine vicinissime alla superficie 
					dei dischi
			\end{itemize}
		\end{itemize}
\end{itemize}

\subsubsection{Prestazioni}
Le prestazioni di un disco eseterno sono determinate da:

\begin{itemize}
	\item Tempo di posizionamento ($T_P$) (seek time), 
		spostamento della testina nella traccia giusta, 
		all'incirca dai 5 ai 20ms, non molto
		ottimizzabile essendo uno spostamento meccanico
	\item Latenza rotazionale ($T_L$) (latency), attendere 
		che il settore d'interesse sia sotto la testina, 
		dipende dalla velocità di rotazione (RPM)
		\begin{equation} 
			RPM=3600\ \implies\ RPS=60\ \implies\ rotazione
			= 16.7ms\ \implies\ T_L = 8.35ms
		\end{equation}
	\item Tempo di accesso, ($T_P + T_L$)  determinato 
		dal tempo di posizionamento e dalla latenza (seek + latency)
	\item Tempo di trasferimento: 
		\begin{equation}
			T = \frac{b}{r \times N}
		\end{equation}
		dove \bt{b} = byte da trasferire, \bt{N} = numero di byte per
		traccia e \bt{r} = velocità rotazione in secondi.
\end{itemize}

\subsubsection{RAID}
Redundant Array of Independent(/Inexpensive) Disks, esistono 7 livelli
(da 0 a 6) non gerarchici di dischi, si tratta di un insieme di dischi
fisici visti dal sistema operativo come un singolo dispositivo logico.
In questo tipo di configurazione i dati sono distribuiti sui dispositivi.


\begin{enumerate}[start=0, label={\bfseries RAID \arabic*:}]
	\item nessuna ridondanza, tutti i dati sono distribuiti
		nei dischi in \tit{strisce} (strip), si utilizza il metodo
		'round robin striping' e si ottiene una maggiore velocità sia 
		in scrittura che in lettura.\\
		Le strip vengono memorizzate in parallelo nei vari dischi. Una
		strip è un multiplo di blocchi.\\
		C'è un'alta probabilità che i dati siano distribuiti in vari 
		dischi e quindi che non ci sia un conflitto di risorse.
	\item Mirrored, il contenuto viene replicato su più dischi, ogni dato 
		viene copiato in un altro disco. Ogni dato viene letto e scritto
		in più dischi. Il vantaggio è il recupero dei dischi immediato, è
		necessario solamente sositituire il disco rotto con quello 
		che ha gli stessi dati. Si ha una copia esatta di ogni disco.
	\item (non commercializzato), dischi sincronizzati, in modo tale che 
		la testina di ogni disco sia nella stessa posizione in ogni disco,
		si usano unità di informazione molte piccole.\\
		Si hanno codici di correzione calcolati tra bit corrispondenti
		nei vari dischi. Si ha una grande ridondanza, ciò fa 
		aumentare di molto il costo.

	\item simile al raid 2, ma ha solo un disco ridondante indipendentemente
		dal numero di dischi nell'array. Non è necessario sapere
		quale dato viene a mancare ma semplicemente quale disco non
		è più funzionante, quindi con questo sistema si sostituisce 
		il disco guasto direttamente. Usa un semplice bit di parità
		per ogni insieme corrispondente di bit, attraverso questi si
		ricostruisce l'informazione e ai dati presenti negli altri dischi.
		Si ha un'alta velocità di trasferimento. La sincronizzazione
		dei dischi è causa di complessità,
		il disco di parità diventa il 'collo di bottiglia' per le
		operazioni in parallelo ed è quello più facile a subire un guasto
	\item Ogni disco opera indipendentemente, ottimo per alti ritmi di 
		richieste I/O, l'informazione di parità viene memorizzata su 
		un disco ad hoc (disco di parità). Il problema di questa 
		configurazione è il disco di parità che diventa un 
		'collo di bottiglia', essendo frequentemente utilizzato è
		quello più probabile a subire dei problemi di malfunzionamento
	\item la parità viene distribuita in dischi diversi, non si ha più il
		collo di bottiglia dei RAID 3\&4. L'allocazione viene
		distribuita con il metodo 'round robin', esattamente come i
		dati nel RAID 0, viene utilizzato nei server di rete, uguale
		al RAID 4 fuorchè per il disco di parità, robustezza fino ad un
		disco. Per avere 'N' dischi occorre averne 'N+1'
	\item Si calcola la parità tramite due metodi distinti che sono memorizzati
		in blocchi separati in dischi differenti. Per avere 'N' dischi 
		occorre averne 'N+2', si ha una robustezza fino a 2 dischi, 
		equivale al RAID 5 con il doppio della parità.
\end{enumerate}

\subsubsection{Dischi SSD}
Solid State Drive, Solid perchè si basa su circuiti integrati ovvero 
\bt{memorie flash} di tipo NAND\\
Il \bt{floating gate} 

\begin{itemize}
	\item non attivo, non interferisce con il control gate 
		e rappresenta bit a 1, di default è in questo stato.
	\item se attivo, tramite alto voltaggio intrappola
		elettroni che rimangono anche in assenza di alimentazione e 
		rappresnetano bit a 0 e rende il transistor
		come se fosse inutilizzabile
\end{itemize}
La struttura di una memoria flash di tipo NAND è organizzata in arraya da 
16 o 32 transistor collegati in serie. La bit line va a 0 solo
se tutti i transistor delle corrispondenti linee della parola sono a 1 (attivi),
deriva dalla funzione booleana NAND. Le letture e le scritture coinvologono l'intera parola.\\
I vantaggi di questi dischi sono:

\begin{itemize}
	\item velocità, non sono coinvolte operazioni meccaniche.
	\item alte prestazioni di I/O e aumenta le prestazioni dei sottoinsiemi
		di I/O 
	\item durata, meno suscettibile a urti e vibrazioni
		rispetto ai dischi magnetici
	\item maggiore durata, non soggetti a usura meccanica
	\item consumo energetico inferiore, meno energia non essendo coinvolte
		parti meccaniche.
	\item funzionalità più silenziose e fredde, minori costi
		energetici
	\item tempo di accesso e latenza inferiori oltre 10 volte rispetto
		a quelli degli HDD
\end{itemize}
Organizzazione di un disco SSD:

\begin{itemize}
	\item Sistema host:
\begin{enumerate}
	\item per accedere ai dati, il sistema operativo richiama
		il software del file system, che richiama a sua volta
		il software del driver di I/O che fornisce l'accesso
		all'SSD
	\item il componente di interfaccia si riferisce all'interfaccia fisica
		ed elettricatra il processore host e l'SSD
\end{enumerate}
	\item SSD:
\begin{enumerate}
	\item Controller: fornisce l'interfacciamento a livello del
		dispositivo SSD e l'esecuzione del firmware
	\item Indirizzamento: logica che esegue la funzione di selezione
		tra i componenti della memoria flash
	\item Buffer/cache dati: RAM ad alta velocità per compensare 
		velocità e aumentare il throughput dei dati
	\item correzione degli errori: logica per il rilevamento 
		e la correzione degli errori
	\item Componenti della memoria flash: singoli chip flash NAND
\end{enumerate}
\end{itemize}
Gli svantaggi degli SSD:

\begin{itemize}
	\item Le performance decadono con l'uso, la dimensione di un blocco 
		delle memorie flash all'interno degli SSD è di solito di 
		512kb, per poter scrivere anche solo un B bisogna portare
		il blocco in cache e modificare l'intero blocco riscrivendolo 
		da capo.\\
		I file sono di solito salvati in pagine da
		4kB quindi 128 pagine per blocco.
		con l'utilizzo dei file essi si frammnetano, le pagine vengono 
		memorizztei in blocchi diversi e le prestazioni decadono.\\
		soluzioni: over-provisioning, vengonon tenuti certi blocchi
		solamente per le scritture; cancellazione delle pagine inattive;
		comando TRIM (avverte il dispositivo quali pagine sono state
		memorizzate logicamente).
	\item si ha un numero limitato di scritture, intorno alle 100.000,
		per risolvere questa limitazione, cache front-ending
		(ospita blocchi più riferiti, politica LRU), distribuzione
		scritture, getsione blocchi esauriti, RAID.
\end{itemize}

\subsubsection{Memorizzazione Ottica}
Inizialmente furono concepiti per organizzare dati audio: 650MB memorizzano
più di 70 minuti audio.\\
Sono principalmente dischi di policarbonato rivestiti con un materiale altamente
riflettente.\\
I dati sono memorizzati come microscopici pozzetti: 

\begin{itemize}
	\item Land
	\item Pit
\end{itemize}
i dati 0 e 1 vengono memorizzati come transizione da land e pit o viceversa
e vengono letti tramite laser.\\
Si ha una densità di memorizzazione costante, infatti si ha una singola traccia
organizzata a spirale e gira a velocità costante, la velocità del disco dipende
dalla posizione in cui si trova.

\subsubsection{CD-ROM}
Caratteristiche: 

\begin{itemize}
	\item Audio: singola velocità
	\begin{itemize}
		\item velocità lineare costante
		\item 1.2 ms$^{-1}$
		\item traccia a spirale lunga 5.27km
		\item memorizza 4391 secondi = 73.2 minuti
	\end{itemize}
	\item la velocità dichiarata è la massima raggiungibile che il lettore può
		raggiungere.
	\item formato dati:
		\begin{itemize}
			\item modo 0 = campo dati vuoto
			\item modo 1 = 2048 byte dati+correzione
			\item modo 2 = 2336 byte dati
		\end{itemize}
\end{itemize}
Accesso casuale su CD-ROM:

\begin{itemize}
	\item difficile causa della velocità lineare costante
	\item spostare la testina in posizione approssimata
	\item configurare la giusta velocità di rotazione 
	\item legere l'indirizzo
	\item altri aggiustamenti per spostarsi sul settore richiesto
\end{itemize}
Non è però efficiente come in una memoria RAM\\
Pro:

\begin{itemize}
	\item Capacità, si utilizzavano come sistemi di bakcup,
		erano più economici degli HDD
	\item facili da produrre su grande scala
	\item rimovibile
	\item robusto
\end{itemize}

Contro:		
\begin{itemize}
	\item Costoso per piccole quantità
	\item lento per accedere ai dati
	\item essendo un CD-ROM è di solo lettura
\end{itemize}

\section{Formulario}

\bt{ \tit{ TODO }  } 


\subsubsection{Altri tipi di memorizzazione ottica}%
\label{subsub:altri_tipi_di_memorizzazione_ottica}

\begin{itemize}
	\item CD-R(ecordable)
	\item CD-RW
	\item Digital video Disk
		usato per riprodurre film, \\
		sono presenti molteplici strati,\\
		ha un'alta capacità di memorizzazione\\
		si usa tutto lo spessore del disco e inoltre si usano entrambi i
		lati di esso,\\
		il diametro del raggio laser è minore quindi si ha una maggiore 
		densità di memoria 

\end{itemize}

\subsection{Nastro magnetico}%
\label{sub:nastro_magnetico}

\begin{itemize}
	\item Accesso seriale
	\item lento
	\item molto economico 
	\item utilizzato per backup e copia di riserva
\end{itemize}
Le informazioni possono essere memorizzate a serpentina, o possono essere scritte 
a blocchi

\end{document}
