\documentclass[arch.tex]{subfiles} 

\begin{document}

\chapter{Seconda Parte}
\section{Input/Output}%
\label{sub:input_output}
Un computer è collegato a innumerevoli apparecchi i quali

\begin{itemize}
	\item gestiscono quantità di dati differenti
	\item velocità diverse
	\item formati diverse
\end{itemize}
È certo che siano più lenti della CPU e della RAM, per ottenere il massimo delle
prestazioni della propria CPU è necessario che le periferiche esterne siano 
controllate da dei moduli comuni: \bt{moduli di input output}.\\
Vari tipi di dispositivi esterni:
\begin{itemize}
	\item Comprensibili dall'uomo\\
		Monitor, stampanti, ...
	\item Comprensibili dalla macchina
	\item Comunicazione\\
		Modem, router
\end{itemize}

\pparagraph{Componenti di un dispositivo esterno}%
\label{ppar:Componenti di un dispositivo esterno}



\begin{itemize}
	\item \bt{Logica di controllo}\\
		Comunica con il modulo di I/O
	\item \bt{Buffer di memoria}\\
		immaggazzina memoria, esempio (logistica container)
	\item \bt{Transducer}\\
		trasforma dati fisici (analogici) in bits o viceversa
\end{itemize}

\pparagraph{Componenti Modulo I/O}%
\label{ppar:Componenti Modulo I/O}



\begin{itemize}
	\item \bt{Registro Dati}, comunica con le linee dei dati
	\item \bt{Registri di controllo}, comunica con le linee dei dati
        \item \bt{Logica dell'I/O}, comunica con le linee indirizzi e le linee di controllo
	\item \bt{Logiche di interfaccia} con i dispositivi esterni, 
		inviano dati, stati e segnali di controllo
\end{itemize}

\pparagraph{Caratteristiche Modulo I/O}%
\label{ppar:Caratteristiche Modulo I/O}


\begin{itemize}
	\item nascondono o rivelano le proprietà del dispositivo alla CPU
	\item Supporto di dispositivi singoli o multipli
	\item Controllo delle funzioni del dispositivo o delega del controllo alla CPU
	\item Caratteristiche del sistema operativo
\end{itemize}

\pparagraph{Funzioni del Modulo I/O}%
\label{ppar:Funzioni del Modulo I/O}


\begin{itemize}
	\item Controllo e temporizzazione
	\item Comunicazione con CPU
	\item Comunicazione con i dispositivi
	\item Buffering dei dati
	\item Rilevazione degli errori
\end{itemize}
\subsection{Tecniche di gestione input/output}%
\label{sub:tecniche_di_gestione_input_output}

\subsubsection{I/O da programma}
Attesa attiva della CPU e si occupa del trasferimento dei dati, la CPU e il modulo
I/O non sono sempre collegati, si spreca molto tempo lasciando la CPU in attesa.\\
I comandi che si possono eseguire sono:\\
CPU invia un indirizzo, che identifica il modulo ( e/o il dispositivo se  si ha moduli $>$ 1 )\\ 
CPU invia comando di:
\begin{itemize}
  	\item \bt{controllo}, cosa deve fare il modulo
	\item \bt{test}, controllo dello stato
	\item \bt{lettura/scrittura}, trasferimento dei dati tramite i buffer
\end{itemize}


\pparagraph{I/O memory mapped}%
\label{ppar:I/O memory mapped}
\bt{ VANTAGGI }:

\begin{itemize}
	\item non necessita istruzioni speciali,\\
		le istruzioni inviate alla memoria principale arrivano anche alle aree di I/O,\\
		il software di controllo può essere scritto in HLL
	\item protezione più agevole,\\
		nascondere aree di I/O allo spazio indirizzato all'utente
\end{itemize}

\bt{ SVANTAGGI }:

\begin{itemize}
	\item non è compatibile con l'uso della \bt{cache}
	\item non è compatibile con architetture a \bt{bus multipli}
\end{itemize}

\subsubsection{I/O guidato da interrupt}
Non c'è l'attesa della CPU, essa viene interrota \tit{ SOLO } quando il dispositivo è pronto\\
La CPU esegue altre operazioni e si ferma \tit{ SOLAMENTE } solamente quando ci sono delle 
effettive interruzioni le quali vengono inviata alla CPU dal modulo di I/O.\\
La procedura nel caso di interruzione:

\begin{itemize}
	\item La CPU salva il contenuto dei registri e del PC
	\item viene interrotto il processo corrente e viene elaborato l'interrupt
\end{itemize}

\subsubsection{Direct Memory Access}
A differenza degli altri due tipi di input di blocco di dati che richiedono l'intervento 
\tit{ attivo } della CPU, questo tipo, richiede il minimo intervento della CPU.
Esso è un pezzo d'hardware aggiuntivo connesso al \tit{ bus } e il \bt{ controllore DMA } 
sostituisce \tit{ quasi } completamente la CPU nelle attività di I/O
\pparagraph{Modulo DMA}%
\label{ppar:Modulo DMA}


\begin{itemize}
	\item Linee dati
		\begin{itemize}
			\item Data Count
			\item Registro dati
			\item Indirizzo registri
		\end{itemize}
	\item Linee indirizzi\\
		Registro Indirizzi
	\item Logica di controllo
\end{itemize}

\pparagraph{Operazioni DMA}%
\label{ppar:Operazioni DMA}
	

\begin{itemize}
	\item CPU comunica al controllore DMA:

		\begin{itemize}
			\item lettura scrittura
			\item indirizzo dispositivo
			\item indirizzo iniziale in memoria del blocco di dati
			\item quantità di dati da trasferire
		\end{itemize}
	\item CPU prosegue con altre attività
	\item il controllore DMA trasferisce i dati e si interfaccia con la memoria principale
	\item il controllore DMA invia un \tit{ interrupt } alla CPU quando ha terminato
		il trasferimento,
\end{itemize}
Il trasferimento dei dati DMA occupa il bus e lo sottrae alla CPU, si possono
utilizzare due metodi differenti per accedere al canale:

\begin{itemize}
	\item Una parola alla volta, cycle stealing, sottrae di tanto in tanto
		per un solo ciclo
	\item Per blocchi, burst mode, è il metodo più efficace in quanto 
		l'occupazione del bus è un'operazione molto onerosa.
\end{itemize}
Il DMA può avere divrse configurazioni:

\begin{itemize}
	\item Bus singolo, il controllore DMA è isolato,\\
		il trasferimento dati utilizza il bus \tit{ due } volte: I/O a DMA, DMA a 
		Memoria
	\item Bus singolo, il controllore DMA è integrato con I/O,\\
		può controllare più di un dispositivo, ogni trasferimento usa il bus
		\tit{ una } volta
	\item Bus I/O separato, il DMA ha bisogno di una sola interfaccia I/O,\\
		il trasferimento dati usa il bus \tit{ una } volta sola.
\end{itemize}

\section{Rappresentazione binari numeri reali}

\subsection{Rappresentazione in modulo e segno}%
\label{sub:rappresentazione_in_modulo_e_segno}
Il bit di segno è quello più a sinistra e:\\
\bt{ 0 } indica positivo\\
\bt{ 1 } indica negativo\\
Per esempio su 4 bit:
\begin{equation}
	0010 = 2\ ;\ 1010 = -2
\end{equation}
Con questa rappresentazione si hanno due rappresentazioni dello zero: $ \pm 0 $ 

\subsection{Complemento a due}%
\label{sub:complemento_a_due}
\tit{ Positivi }: da \tit{ 0 } ( composto di \tit{ n } zeri ) a \tit{ $ 2^{n-1} - 1$  } 
( uno zero seguito da \tit{ n - 1 } uni )\\
\tit{ Negativi }: da \tit{ -1 } ( composto da \tit{ n } uni ) a \tit{ $ -2^{n-1} $  } 
( un uno seguito da \tit{ n - 1 } zeri ).\\
L'1 a sinistra indica il peso negativo, mentre gli altri bit sono pesi positivi.\\
La formula generale è:

\begin{equation}
	numero = -2^{n-1} a_{n-1} + \sum_{i=0}^{n - 2} 2^i a_i
\end{equation}
Per esempio su 4 bit:

\begin{equation}
	1000 = -8\ ;\ 0111 = 7\ ;\ 1111 = -1\ ;\ 0000 = 0
\end{equation}
Per fare velocemente il complemento dei numeri in complemento a due basta:\\
partendo da sinistra si lascia il numero uguale fino al primo uno incluso, e si fa il 
complemento del resto.\\
\bt{ VANTAGGI }:\\
singola rappresentazione dell'uno, facili le operazioni aritmetiche, facile negazione

\input{sub/complemento_due_tab}

\subsection{Standard IEEE-754}%
\label{sub:standard_ieee754}
È lo standard per i numeri in virgola mobile, ha un \tit{ doppio } formato: singolo
a 32 bit e doppio a 64 bit, l'esponente ha 8 o 11 bit. A sinistra della virgola si ha
un \tit{ uno implicito }.

\pparagraph{FORMATO SINGOLO}%
\label{ppar:FORMATO SINGOLO}
\begin{itemize}
	\item 1 bit per il \tit{ segno } 
	\item 8 bit per \tit{ esponente polarizzato },\\
		ovvero da 1 a 254 ( -126 a 127 ) 
	\item 23 bit per la \tit{ mantissa o frazione } 
\end{itemize}

\begin{equation}
	\pm 2^{e - 127} \times 1.f
\end{equation}
Certe configurazioni assumono valori particolari:

\begin{itemize}
	\item exp 0, mantissa 0: 0 positivo ( $0^+$ )  o negativo ( $ 0^- $  ) 
		( in base al bit di segno )
	\item exp tutti 1, mantissa 0: infinito positivo o negativo $ \pm  \infty $
	\item exp 0, mantissa non \tit{ nulla }: numero \tit{ denormalizzato },
		bit a sinistra della virgola è 0 non 1: $ 2^{-126} \times 0.f $ 
	\item exp tutti 1, mantissa non nulla: errore, not a number NAN
\end{itemize}
Questa rappresentazione offre una maggiore quantità di numeri rappresentabili al costo
però di una più complicata implementazione dell'aritmetica:\\
controllo zero, allineamento mantisse, somma o sottrazione mantisse, normalizzazione del
risultato

\clearpage
\section{Linguaggio Macchina}%
\label{sub:linguaggio_macchina}

Il linguaggio macchina è costituito da:
\begin{itemize}
	\item Insieme istruzioni eseguibili dalla CPU
	\item Tipologia dei dati manipolabili
	\item Tipi di operandi
\end{itemize}
Nessun linguaggio macchina è superiore ad un altro, ed esso dipende dall'ambito
applicativo e dalle funzioni che si devono far svolgere.

\pparagraph{Elementi Istruzioni Macchina}%
\label{ppar:Elementi Istruzioni Macchina}


\begin{itemize}
	\item Codice operativo, specifica l'operazione da eseguire
	\item Riferimento all'operando sorgente, specifica l'operando che 
		rappresenta l'input dell'operazione
	\item Riferimento all'operando risultato, dove va messo
		il risultato ottenuto
	\item Riferimento all'istruzione successiva
\end{itemize}

\pparagraph{Locazione operandi}%
\label{ppar:Locazione operandi}


\begin{itemize}
	\item \bt{Memoria centrale}, o ( virtuale ) 
	\item \bt{Registri della CPU}, ognuno ha il proprio numero identificativo
	\item \bt{Dato immediato} con istruzione
	\item \bt{ Dipsositivi di I/O }
\end{itemize}
L'\tit{ istruzione } è una sequenza di bit divisa in campi, viene usata una 
rappresentazione simbolica delle configurazioni di bit. Pure gli operandi
hanno la propria rappresentazione simbolica

\pparagraph{Formato Istruzione di 16 bit}%
\label{ppar:Formato Istruzione di 16 bit}


\begin{itemize}
	\item 4 bits, \bt{ Codice operativo } ( opcode ) 
	\item 6 bits, \bt{ Indirizzo operando }, ( operand reference )
	\item 6 bits, \bt{ Indirizzo operando }, ( operand reference ) 
\end{itemize}

\pparagraph{Tipi di istruzioni}%
\label{ppar:Tipi di istruzioni}


\begin{itemize}
	\item elaborazione dati, istruzioni aritmetico logiche, nei registri della
		CPU
	\item Immagazinamento dei dati in Memoria o recupero dati dalla Memoria
	\item Trasferimento dati ( I/O ) 
	\item Controllo del flusso del programma		
\end{itemize}

\pparagraph{Indirizzi necessari per un'istruzione}%
\label{ppar:Indirizzi necessari per un'istruzione}



\begin{itemize}
	\item un indirizzo per ogni operando ( 1 o 2 ) 
	\item uno per il risultato, ( 1 implicito ) 
	\item indirizzo dell'istruzione successiva, ( entrambi impliciti ) 
\end{itemize}
Quindi possono essere al massimo 4, ( cosa molto rara e dispendiosa), ma in genere
sono 1, 2 o 3 per gli operandi/risultati\\
Quando si riferisce ad un solo registro vuol dire che il secondo è implicito ed è 
memorizzato in un registro, per esempio nell'accumulatore.\\
Quando non si riferisce a nesssun indirizzo vuol dire che tutti gli indirizzi sono
impliciti e si sta utilizzando una pila in cui si accumulano i vari indirizzi
utilizzati.

\begin{itemize}
	\item Se si utilizzano \bt{meno indirizzi} si eseguono istruzioni più elementari
		e corte, se si hanno più istruzioni per uno stesso programma implica un tempo 
		di esecuzione più lungo.\\
		L'archiettura RISC utilizza questa filosofia, 
		significa \bt{Reduced Instruction Set Computer}
		e si basa sul velocizzare le istruzioni più frequenti.
	\item se si utilizzano \bt{più indirizzi} le istruzioni diventeranno 
		più complesse quindi impiegherà meno tempo per eseguire istruzioni
		più complesse ma userà più potenza per istruzioni semplici.\\
		L'architettura CISC si basa su questo principio 
		\bt{Complex Instruction Set Computer}
\end{itemize}

\pparagraph{Progettazione di un'istruction set}%
\label{ppar:Progettazione di un'istruction set}


\begin{itemize}
	\item \bt{Repertorio}:\\
		quante e quali operazioni
	\item \bt{Tipo di dato}:\\
		su quali dati
	\item \bt{Formato}:\\
		lunghezza istruzione, numero indirizzi, dimensione dei campi
	\item \bt{Registri}:\\
		numero di registri della CPU indirizzabili dalle istruzioni
	\item \bt{Indirizzamento}:\\
		modo di individuare gli indirizzi degli operandi
\end{itemize}

\subsubsection{Tipi degli operandi}

\begin{itemize}
	\item Indirizzi, rappresentati come interi senza segno
	\item Numeri\\
		limite al modulo\\
		limite alla precisione
	\item Caratteri ( stringhe ) 
	\item Dati logici, variabili booleane per il controllo del flusso 
		dell'esecuzione.
\end{itemize}

I numeri vengono rappresentati:

\begin{itemize}
	\item Interi ( con la virgola fissa ) 
	\item Virgola Mobile ( Floating point, IEEE754 ) 
	\item Decimali impaccati, operazioni di I/O,
		non efficienti per rappresentare una cifra decimale
		si utilizzano 4 bit, ovvero impiegare solo 10 delle 16 configurazioni
		disponibili,lo scopoo è di evitare la conversione.\\
		es: 246 viene rappresentato come:

		\begin{equation}
			246 = \underset{200}{0010}\ \underset{ + 40	}{0100}\
			\underset{ + 6}{0110}
		\end{equation}
\end{itemize}
I caratteri vengono rappresentati in \tit{ASCII} ( American Standard Code for
Infromation Exchange ) da 7 bit, quindi si hanno in totale 128 configurazioni
disponibili.\\
Si ha di solito 1 bit per i caratteri di controllo.\\
C'è una versione estesa da 8 bit in cui si possono rappresentare 256 configurazioni.

\pparagraph{Dati logici}%
\label{ppar:Dati logici}

\begin{itemize}
	\item n bit, invece che singolo dato
	\item manipolare bit separatamente
\end{itemize}

\pparagraph{Tipi Dati Intel x86}%
\label{ppar:Tipi Dati Intel x86}


\begin{itemize}
	\item 8 (byte), 16 (word), 32 (doppia parola), 64 (quadword), 128 (double quadword) bits
	\item L'indirizzamento è per unità di 8 bit (1 byte)
	\item Una double word da 32 bit inizia da un indirizzo divisibile per 4
	\item Non si ha la necessità di allineare gli indirizzi per le strutture dati in memoria
	\item Bisogna allineare i dati per i trasferimenti dati nel bus
\end{itemize}

\pparagraph{Tipi di operazioni Intel x86}%
\label{ppar:Tipi di operazioni Intel x86}


\begin{itemize}
	\item Trasferimento Dati,\\
		comporta specificare: la sorgente (dove si trova), 
		la destinazione (dove andrà messo),
		la lunghezza del dato da trasferire
	\item Aritmetiche,\\
		somma, sottrazione, moltiplicazione, divisione.\\
		I numeri interi hanno sempre il segno, viene utilizzata anche per numeri con la virgola mobile e inoltre
		possono esserci le operazioni di:\\
		incremento (+1), decremento(-1), negazione (inversione del segno, trovare il numero opposto), calcolo valore 
		assoluto
	\item Logiche,\\
		sono operazioni dirette sugli specifici bit, operazioni di: AND, OR, NOT, XOR, EQUAL,
		possono anche essere eseguite parallelamente su tutti i bit di un registro
	\item Conversione
	\item I/O
	\item Sistema
	\item Trasferimento del controllo,
		\begin{itemize}
		\item \tit{Salto condizionato} (branch), esempio BRE R1, R2, X 
		(salta a X se R1 equivale a R2),\\
		si ha la necessità di saltare se si deve eseguire 
		più volte una stessa operazione come in 
		un 'for, while' loop, favorisce la programmazione modulare.
		\item	\tit{Salto incondizionato}, salta all'istruzione \tit{ x } , 
		non ha operandi, non si devono verificare  delle condizioni.
		\item \tit{ Chiamata di procedura }: una procedura è un pezzo di 
		programma a cui si può assegnare un nome e che permette di eseguirlo
		indicandolo con il nome. Risparmia la scrittura di codice e lo si può
		delegare. Ci sono deu istruzioni obbligatorie: la chiamata e il ritorno.\\
		L'indirizzo di ritorno ha 
		3 luoghi di memorizzazione differenti:

			\begin{itemize}
			\item Registro, non funzionale quando sono presenti 
				dei cicli ricorsivi (ovvero che si 'richiamano')
			\item All'inzio delle procedura chiamata, 
				non funzionali sempre in presenza di cicli ricorsivi
			\item Cima della pila, ovvero si utilizza una porzione di 
				memoria nella quale le scritture e le letture
				avvengono sempre in 'cima'. Così si richiamano 
				gli indirizzi che sono stati per ultimi scritti
				nella pila e che si trovano appunto in cima, 
				evitando il problema dei loop ricorsivi.
			\end{itemize}
		\end{itemize}
	\end{itemize}

\subsection{Linguaggio Assembly}%
\label{sub:linguaggio_assembly}
Questo linguaggio è ad un livello più alto rispetto al linguaggio macchina ed è più comprensbile dall'uomo.\\
Gli indirizzi numerici (binario) vengono interpretati come indirizzi simbolici (A, B, ...,Z),\\
I codici operativi diventano simboli (SUB, ADD, BRE).\\
L'assemblatore è un programma che traduce dal linguaggio assembly al linguaggio macchina.

\subsubsection{Big / Little Endian}
I bit nella memoria vengono memorizzati in maniera differente in base all'architettura del calcolatore, ovvero:

\begin{itemize}
	\item Big Endian,\\
		I bit più significativi vengono memorizzati prima negli indirizzi, da sinistra a destra
	\item Little Endian,\\
		I bit meno significativi vengono memorizzati negli ultiimi indirizzi, da destra a sinistra.	
\end{itemize}


\section{Modi di indirizzamento}%
\label{sub:modi_di_indirizzamento}

Esistono diversi tipi per specificare l'indirizzo degli operandi:

\begin{itemize}
	\item Immediato
	\item Diretto
	\item Indiretto
	\item Registro
	\item Registro indiretto
	\item Spiazzamento
	\item Pila
\end{itemize}


\pparagraph{Immediato}%
\label{sub:immediato}


L'operando è specificato nell'istruzione stessa, (nella parte del campo 
indirizzo)\\
\bt{VANTAGGIO}: non si esegue nessun accesso in Memoria
(operazione molto onerosa, in quanto implica l'occupazione del bus)\\
\bt{SVANTAGGIO}: limitato dalla dimensione del campo indirizzo.\\
Se abbiamo per esempio 6 bit destinati al campo indirizzo, avremo  $ 2^6 $ 
valori diversi.


\pparagraph{Diretto}%
\label{sub:diretto}
Il campo indirizzo contiene l'indirizzo dell'operando in Memoria.\\
\bt{SVANTAGGIO}: un accesso in Memoria (operazione onerosa) e, spazio di indirizzamento 
limitato legato alla grandezza della memoria.


\pparagraph{Indiretto}%
\label{sub:indiretto}
Il campo indirizzo contiene l'indirizzo di una cella di Memoria che contiene 
l'indirizzo dell'operando. \\
\bt{VANTAGGIO}: Con parole di lungehzza N si possono indirizzare
$ 2^n $ entità diverse, $ n $ deve essere uguale o inferiore alla
grandezza del campo indirizzo.\\
\bt{SVANTAGGIO}: 2 accessi alla memoria.


\pparagraph{Registro}%
\label{sub:registro}
L'operando si trova in un registro indicato nel campo indirizzo\\
\bt{VANTAGGIO}: pochi bit per l'indirizzamento.\\
\bt{SVANTAGGIO}: limitato dal numero di registri disponibili dal 
tipo di architettura.


\pparagraph{Registro Indiretto}%
\label{sub:registro_indiretto}
Si basa sullo stesso principio dell'indirizzamento a registro, l'operando 
si trovan in una cellla di Memoria puntata dal contenuto del registro.\\
\bt{VANTAGGIO}: si ha solo 1 accesso in memoria a differenza dell'indirizzamento indiretto,
si ha anche un grande spazio di indirizzamento (che dipende dal numero di registri e dalla
lunghezza del campo indirizzo )

\pparagraph{Spiazzamento}%
\label{sub:spiazzamento}
È la combinazione dell'indirizzamento diretto e a registro indiretto. Il campo indirizzo
è suddiviso in due parti:

\begin{enumerate}
	\item il valore di base ( A )
	\item un registro  ( R ) contiene l'indirizzo di un valore da sommare ad A
\end{enumerate}
Alcuni esempi:

\begin{itemize}
	\item l'indirizzamento \bt{relativo}, R è il Program Counter.
	\item L'indirizzamento \bt{registro-base}, A contiene lo spiazzamento, 
		R contiene il puntatore all'indirizzo base.
	\item L'\bt{indicizzazione} ha in 'A' l'indirizzo base e in R lo 'spiazzamento' 
		( offset ), per indicare gli operandi da un certo punto della memoria 
		basta incrementare il contenuto di R di 1.
\end{itemize}
\pparagraph{Stack/Pila}%
\label{sub:stack_pila}
La pila è una sequenza lineare di locazioni riservate della Memoria, c'è un puntatore (che si 
trova nel registro SP, stack pointer, ha come indirizzo la cima della pila). L'operando
si trova nella cima della pila, si può considerare come un'evoluzione dell'indirizzamento a
registro indiretto.
\subsection{Formato delle istruzioni}%
\label{sub:formato_delle_istruzioni}
Il formato delle istruzioni è come sono scritte le istruzioni date alla macchina, influsice
la struttura dei campi dell'istruzione, include il codice operativo, include uno o più operandi
e generalmente si ha più di un formato per linguaggio macchina.

\subsubsection{Lunghezza delle istruzioni}
È strettamente correlata al formato delle istruzioni, è influenzata e influenza:

\begin{itemize}
	\item La dimensione della Memoria
	\item L'organizzazione della Memoria
	\item Struttura del bus
	\item La complessità della CPU
	\item La velocità della CPU
\end{itemize}
Per sfruttare al meglio tutte le risorse di un calcolatore deve essere un giusto compromesso
fra un repertorio delle istruzioni potente e la necessità di risparmiare spazio ( fisicamente
nella parte hardware della macchina).

\pparagraph{Tipi di formati delle istruzioni}%
\label{ppar:Tipi di formati delle istruzioni}


\begin{itemize}
	\item Lungehzza fissa ( fixed length ),\\
		esempio: PDP-8, PDP-10
	\item Formati a lunghezza variabile o ibrida ( hybrid/variable length ),\\
		esempio: PDP-11, VAX, Intel x86, questo tipo aggiunge complessità
		al realizzazione della macchina, ma può renderla più potente per certi 
		utilizzi specifici.
\end{itemize}

\subsubsection{Allocazione dei bit}
Come i bit vengono allocati dipende dai diversi tipi di indrizzamnento usati da una determinata
architettura, dal numero variabile degli operandi ( 0, 1, 2 ),
il numero dei registri, dei banchi registri ( tipi di 'buffer' di memoria ).
Dipende anche dall'intervallo degli indirizzi ( ogni quanto viene ripetuto un indirizzo ) e dalla
loro granularità ( se sono a byte o parola ), l'indrizzamento a byte è più oneroso
ma utile per la manipolazione dei caratteri.

\subsection{Approfondimento sul funzionamento della CPU}%
\label{sub:approfondimento_sul_funzionamento_della_cpu}

La CPU, essendo il componente hardware più potente della macchina è la parte più importante,
essa ha i compiti di:

\begin{itemize}
	\item Prelevare le istruzioni ( Instruction Fetch )
	\item Interpretare le istruzioni ( Instruction Decode ) 
	\item Prelevare Dati ( Operand Fetch ) 
	\item Elaborare Dati ( Execute ) 
	\item Scrivere Dati ( Write Back ) 
\end{itemize}

\pparagraph{Componenti principali CPU}%
\label{ppar:Componenti principali CPU}


\begin{itemize}
	\item ALU, l'unità aritmetico logica, il 'cervello' della CPU
	\item Registri, la memoria della CPU
	\item Unità di Controllo, le parti che verificano il corretto funzionamento del
		processore
\end{itemize}
La CPU è collegata al bus di sistema per poter interagire con gli altri componenti 
dell'elaboratore
\subsubsection{Registri}
I registri sono uno 'spazio' di lavoro in cui la CPU può memorizzare i dati che ha 
elaborato senza dover interagire con la Memoria Principale, essendo un'operazione molto onerosa
e che si deve cercare di limitare il più possibile.\\
I registri sono al vertice della gerarchia di memoria. Essi possono avere funzioni diverse
determinate dall'impianto progettuale della CPU.

\pparagraph{Tipi di Registri}%
\label{ppar:Tipi di Registri}



\begin{itemize}
	\item \bt{Utente}, vengono utilizzati dal 'programmatore' per memorizzare internamente
		i dati alla CPU e successivamente da elaborare.
	\item \bt{di Controllo e di Stato}, utilizzati dall'unità di controllo per monitorare
		le operazioni svolte dalla CPU, sono anche utilizzati dai programmi del sistema
		operativo per controllare l'esecuzione dei programmi.
\end{itemize}
Con 'programmatore' ci si riferisce a:
\begin{itemize}
	\item L'umano che programma in assembly, ( che poi viene trasformato in codice macchina
		dall'assemblatore)
	\item Il compilatore che produce un codice in assembly da un programma in HLL 
		( Linguaggio ad Alto Livello ) 
\end{itemize}
I registri che sono visibili all'utente sono:
\begin{itemize}
	\item Uso generale ( general purpose ),\\
		possono essere ad uso generale o dedicati a particolari funzioni, possono
		memorizzare indirizzi, dati
	\item memorizzazione dei dati
	\item memorizzazione di indirizzi
	\item memorizzazione dei codici di condizione
\end{itemize}
La memoria principale può essere organizzata logicamente come un insieme di
'segmenti' ( spazi di indirizzamento multipli ).\\
Un \tit{segmento} contiene locazioni di memoria indirizzabili, si può indicare
all'interno della memoria fisica la 'base' del segmento ( dove comincia ) e la sua
'lunghezza' ( quanto è lungo effettivamente ) 

\pparagraph{Registri ad uso generale:}
Questi registri si possono dividere in due sottocategorie:

\begin{itemize}
	\item Effettivamente ad uso generale,\\
		aumentano la flessibilità e le opzioni disponibili al 'programmatore',\\
		aumentano le dimensioni dell'istruzione e della sua complessità, in quanto necessitano
		di uno spazio separato nel formato dell istruzioni che può variare la lunghezza 
		in base al numero di registri.
	\item Specializzati,\\
		le loro istruzioni sono più piccole e veloci,\\
		a discapito di un'inferiore flessibilità
\end{itemize}
In genere il numero dei registri generali varia da 8 a 32, se ce ne fossero meno di 8 si avrebbe un maggior
numero di accessi in memoria principale ( operazione onerosa ), se fossero più di 32 non si limiterebbe
l'accesso alla memoria e aggiungerebbe molta complessità alla struttura della CPU.\\
Tuttavia l'architettura RISC arriva ad utilizzare fino a centinaia di registri.

\pparagraph{Lunghezza dei registri:}
Generalmente un registro è lungo abbastanza da poter contenere un indirizzo della memoria principale e 
da contenere una 'full word'

\pparagraph{Registri per memorizzazione di Codici di Condizione:}
Si tratta dell'insieme di bit individuali che possono essere letti implicitamente da un programma
non possono essere impostati da un programma

\pparagraph{Registri di Controllo e di Stato:}
Sono registri che abbiamo già incontrato:

\begin{itemize}
	\item Progrma Counter ( PC ), il registro ceh tiene il 'conto' delle istruzioni da svolgere
	\item Instruction Register ( IR ), il registro che contiene le istruzioni da eseguire
	\item Memory address register ( MAR ), il registro degli indirizzi di memoria
	\item Memory Buffer Register ( MBR ), un registro di buffer, ovvero una memoria temporanea interna al
		processore
\end{itemize}

\pparagraph{Program Status Word:}
La PSW è un insieme di bit che include codici di condizione fra cui:\\
il segno dell'ultimo risultato, zero, riporto, uguale, overflow, abilitazione/disabilitazione interrupt, supervisore

\pparagraph{Modo Supervisore:}
Si tratta di una modalità che permette al Sistema Operativo di utilizzare le procedure del Kernel, che agiscono su componenti
critiche del sistema, ovvero l'esecuzione di istruzioni privilegiate. Essa è disponibile SOLAMENTE al sistema operativo e non 
all'utente o al programmatore in assembler.

\subsubsection{Ciclo di esecuzione CPU con indirettezza:}
Durantei il ciclo di esecuzione della CPU le fasi di fetch e di execute hanno un sottociclo 
chiamato \bt{ indirettezza } .\\
Al fine di recuperare gli operandi indicati in un'istruzione può essere necessario accedere più volte in memoria
secondo la modalità di indirzzamento indiretto.

\pparagraph{Flusso dei dati}%
\label{par:flusso_dei_dati}
L'instruction Fetch generalmente si suddivide in queste operazioni:

\begin{itemize}
	\item L'indirizzo dell'istruzione successiva 'x' è contenuta nel PC;
	\item L'indirizzo dell'istruzione 'x' viene spostato nel MAR;
	\item L'indirizzo 'x' viene emesso nel bus indirizzi;
	\item L'unità di controllo richiede una lettura nella memoria principale;
	\item Viene letto l'indirizzo nella memoria principale;
	\item L'indirizzo ottenuto viene inviato tramite il bus dati e viene 
		ricevuto e copiato dal MBR;
	\item L'indirizzo viene spostato nell'IR
	\item Viene incrementato il PC con l'indirizzo dell'istruzione 'x+1'
\end{itemize}


\pparagraph{Data Fetch}%
\label{par:data_fetch}
Il ciclo del data fetch comprende:

\begin{itemize}
	\item Viene esaminato l'IR;
	\item Se il codice operativo ( opcode ) dell'istruzione richiede un indirizzamento indiretto
		si esegue il ciclo di indirettezza:
		\begin{itemize}
			\item N bit più a destra del MBR vengono trasferiti nel MAR;
			\item L'unità di controllo richiede la lettura dalla memoria principale;
			\item Il risultato della lettura, l'indirizzo dell'operando, viene trasferito
				nel MBR;
		\end{itemize}
\end{itemize}

\pparagraph{Execute}%
\label{par:execute}
Questa parte del ciclo può variare molto in base al tipo di architettura, dipende dal tipo 
di istruzioni che bisogna eseguire e può includere le operazioni di:

\begin{itemize}
	\item Lettura/scrittura della Memoria;
	\item Input/Output;
	\item Trasferimento di dati fra registri e/o nei registri;
	\item Operazioni della ALU;
\end{itemize}

\pparagraph{Interrupt}%
\label{par:interrupt}
Esso è semplice e prevedibile, si svolge come segue:

\begin{itemize}
	\item Viene salvato il contenuto del PC, al fine di recuperare 
		il ripristino dell'esecuzione dopo
		la gestione dell'interruzione
	\item Il PC viene caricato con l'indirizzo della prima istruzione 
		della routine di gestione dell'interruzione
	\item Il fetch dell'istruzione viene puntato al PC
\end{itemize}

\pparagraph{Prefetch}%
\label{par:prefetch}
È la fase di prelievo dell'istruzione e accede alla memoria principale, quest'istruzione viene di solito
eseguita durante la fase di esecuzione dell'istruzione corrente ( durante questa fase non si deve accedere in memoria ).\\
Questa procedura può diventare inutile se sono in esecuzione delle istruzioni di 'jump' o 'branch' che vanno
a modificare il contenuto delle istruzioni da eseguire.


\section{Pipeline}%
\label{sec:pipeline}
Il concetto di \bt{pipeline} è quello di suddividere il lavoro e:

\begin{itemize}
	\item eseguire più attività contemporaneamente
	\item eseguire il lavoro in un tempo minore
\end{itemize}
Tuttavia non si può raggiungere il parallelismo totale come conseguenza della \bt{
dipendenza funzionale}, ovvero quando si necessità che l'attività precedente sia
terminata per poter accedere ai dati che ha elaborato.\\
Nella pipeline i lavori sono affidati a degli \bt{esecutori} che possono essere
di diversi tipi:

\begin{itemize}
	\item generici, ogni esecutore può eseguire un lavoro completo,
		ogni esecutore ha le stesse risorse, ha lo stesso throughput del
		parallelismo totale
	\item specializzati, ogni esecutore svolge sempre la stessa fase,
		ogni esecutore è limitato alla propria fase, ogni lavoro passa 
		da un'esecutore all'altro, questo tipo utilizza meno risorse.
\end{itemize}
Il secondo metodo è quello più diffuso in quanto:

\begin{itemize}
	\item Ogni lavoro viene suddiviso in un certo numero di fasi (i)
	\item Ogni fase è svolta da operatori diversi
	\item In ogni istante sono eseguite fasi diverse
	\item In ogni fase successiva ogni operatore riesegue la stessa fase.
\end{itemize}
Le fasi del ciclo esecutivo di un'istruzione sono:

\begin{itemize}
	\item prelevare istruzione
	\item interpretare istruzione
	\item prelevare dati
	\item elaborare dati
	\item memorizzare dati
\end{itemize}
Ognuna di queste fasi è eseguita da una diversa unità funzionale della CPU,
per esempio l'ALU esegue la fase di elaborazione dati.\\
Per non perdere nessuna informazione senza dover utilizzare la memoria 
principale si usano dei buffer ( registri temporanei ), nei quali si scrivono 
i dati utili alla fase successiva. Ne viene posto uno fra ogni fase.\\
Per aumentare le prestazioni bisogna:

\begin{itemize}
	\item decomporre maggiormente il lavoro
	\item rendere le fasi più indipendenti fra loro e con
		una durata simile
\end{itemize}
Tuttavia aggiungere più fasi alla pipeline può essere una fonte di criticità 
perchè si creano più dipendenze e più possiblità di malfunzionamenti.

\subsection{Pipeline hazards}%
\label{sub:pipeline_hazards}

Una situazione di criticità della pipeline in cui:\\
l'istruzione successiva non può essere eseguita nel ciclo di clock 
immediatamente successivo ( stallo ).

\begin{enumerate}
	\item sbilanciamento delle fasi
	\item problemi strutturali
	\item dipendenza dai dati
	\item dipendenza dal controllo
\end{enumerate}

\pparagraph{Sbilanciamento delle fasi}%
\label{par:sbilanciamento_delle_fasi}
Questa criticità si ha quando non tutte le fasi richiedono lo stesso tempo
di esecuzione.\\
per esempio: la lettura di un operando tramite registro o mediante indirizzamento
indiretto.\\
La suddivisione in fasi va misurata in base alla durata 
dell'istruzione più lunga.\\
Non tutte le istruzioni richiedono le stesse  fasi e le stesse risorse.\\
Il rischio che si corre è: se un esecutore ha svolto
un lavoro e deve passare un dato al successivo esecutore finchè questo
sta ancora svolgendo la propria mansione rischia di sovrascrivere i dati 
dell'ultimo.\\
Come soluzione ci sono due opzioni:

\begin{itemize}
	\item decomporre le fasi più onerose in più sottofasi,\\
		ha un elevato costo e una scarsa utilizzazione.
	\item duplicare gli esecutori delle fasi più onerose e farli operare in 
		parallelo,\\
		per esempio due ALU, una per l'aritmetica intera e una per
		l'aritmetica a virgola mobile.
\end{itemize}

\pparagraph{Problemi strutturali}%
\label{par:problemi_strutturali}
Accadono quando due o più istruzioni che sono già nella pipeline richiedono di 
accedere ad una stessa risorsa nello stesso ciclo di clock. In questo caso 
gli accessi devono essere sequenziali e non paralleli.\\
Per risolvere questo tipo di problema si attuano queste strategie:

\begin{itemize}
	\item Introduzione fasi non operative ( nop ) 
	\item suddivisione delle memorie in modo tale che permettano gli
		accessi paralleli:\\
		per esempio una cache per le istruzioni e una per i dati.
\end{itemize}

\pparagraph{Dipendenza dai dati}%
\label{par:dipendenza_dai_dati}
Accade quando una fase non può essere eseguita in un certo ciclo di clock 
perchè i dati di cui ha bisogno non sono ancora disponibili, deve attendere
il termine dell'elaboraione di una fase precedente.\\
Avendo due istruzioni: $i$ e $i+1$, si possono 
avere questi tipi di criticità:

\begin{itemize}
	\item \bt{read after write}: lettura dopo scrittura,\\
		i+1 legge prima che i abbia scritto,
		\begin{enumerate}
		\item Si introducono fasi non operative (nop) quindi fasi di stallo
		\item si propagano i dati appena sono stati calcolati, 
			( dataforwarding ),\\
		se l'operando viene calcolato alla fine della fase \tit{ EI } 
		lo si comunica subito doppo questa fase ( e non nella fase successiva
		 \tit{ WO } )  e si riduce di uno le fasi di stallo.
		\item Si riordinano le istruzioni in maniera più efficiente dal compilatore.
		\end{enumerate}
	\item \bt{ Write After Write }: scrittura dopo scrittura,\\
		i+1 scrive prima che i abbia scritto
	\item \bt{ Write After Read }: scrittura dopo lettura,\\
		i+1 scrive prima che i abbia letto ( caso raro in pipeline )  
\end{itemize}

\pparagraph{Dipendenza dal controllo}%
\label{par:dipendenza_dal_controllo}
Accade quando entra nella pipeline un'istruzione di salto condizionato o incodizionato.\\
Nel caso del salto condizionato:

\begin{itemize}
	\item Si mette in stallo la pipeline finchè non si conosce l'esito 
		della condizione del salto
	\item Si individuano le istruzioni critiche e si aggiunge un'apposita logica
		di controllo, nel farlo si complica il compilatore e l'hardware specifico
	\item Si aggiungono flussi multipli, ovvero si caricano le due possibili istruzioni
		che sono specificate nell'istruzione di salto:\\
		l'istruzione \tit{ n } o l'istruzione \tit{ i+1 }.
	\item Si esegue il prefetch dell'istruzione target del salto.
	\item Buffer circolare ( \tit{ loop buffer }  ),\\
		ha una capienza di 256 bytes, viene indirizzato al byte, dato un indirizzo di 
		target controllo se c'è nel buffer: 8 bit meno significativi ( come indice 
		buffer ), gli altri bit più significativi si utilizzano per verificare se la 
		destinazione del salto sta già nel stack pointer
		\begin{itemize}
			\item Piccola e veloce memoria che ricorda tutte le ultime n
				instruzioni prelevate
			\item In caso di salto si controlla se l'istruzione 
				è già dentro il buffer
			\item Utile in caso di loop, se il buffer contiene tutte le istruzioni
				da eseguire nel loop esse devono essere caricate una sola 
				volta nella memoria ( scenario molto frequente con i loop )
			\item Accopiato al pre-fetch 
		\end{itemize}
	\item Predizione dei salti:\\
		Si possono avere due tipi di approcci:
		\begin{itemize}
			\item \bt{ Statico },\\
				prevedo di saltare \tit{ sempre },\\
				prevedo di \tit{ non } saltare \tit{ mai },\\
				prevedo di saltare in base al \tit{ codice operativo } 
			\item \bt{ dinamico },\\
				bit take/not taken,\\
				tabella dell storia dei salti,\\
				Questo approccio cerca di migliorare la qualità della 
				predizione del salto memorizzando la \tit{ cronologia
				delle istruzioni di salto condizionato} di un certo programma.\\
				Per questo ad \bt{ ogni } istruzione di salto condizionato
				associo \bt{ 1 o 2 bit } per ricordae l'andamento delle ultime
				istruzioni. I bit vengono memorizzati in una locazione temporanea
				ad accesso \bt{ molto veloce }.
				\begin{itemize}
					\item 1 bit,\\
						ricorda come è andata l'ultima volta quindi
						predice di comportarsi in maniera uguale:\\
						se \bt{ 1 } predico di saltare,\\
						se \bt{ 0 } predico di non saltare,\\
						se \bt{ sbaglio } predizione inverto il bit.
					\item 2 bit,\\
						Ricorda come è andata la predizione degli ultimi
						due salti, per invertire la predizione si 
						ha bisogno di due errori consecutivi
				\end{itemize}
		\end{itemize}
	\item Salto ritardato,\\
		finchè non si è a conoscenza dell'esito dell'istruzione di salto, per non
		rimanere in stallo si esegue un'istruzione che non dipende dal salto,
		il compilatore alloca un'istruzione 'opportuna' subito dopo l'istruzione 
		di salto quindi la CPU esegue sempre PRIMA l'istruzione presente nel 
		\tit{ branch delay slot } e dopo altera l'ordine di esecuzione  delle istruzioni
\end{itemize}

\section{CISC e RISC}%
\label{sec:cisc_e_risc}

Nell'evoluzione dei calcolatori si investono molti più capitali nel reparto \bt{software} 
piuttosto che in quello \bt{hardware}. Con l'avvenire dei \tit{linguaggi ad alto livello} ( HLL 
è più semplice esprimere algoritmi complessi in maniera coincisa e delegano al compilatore il 
compito di tradurre questi in \tit{ linguaggio macchina }. Questi HLL supportano costrutti
di programmazione strutturata, ovvero i diversi paradigmi.\\
Per poter ridurre il \tit{ gap semantico } ovvero ciò che sta fra le istruzioni in HLL a quelle
in linguaggio macchina, una soluzione dei progettisti hardware è stata quella di:

\begin{itemize}
	\item Ampliare il set delle istruzioni
	\item Aggiunta di diversi modi di indirizzamento
	\item Implementazione hardware di costrutti di linguaggi ad alto livello
\end{itemize}
Così si semplifica il lavoro del compilatore, l'esecuzione diventa più efficiente, si possono
supportare HLL più complessi.\\
Un approccio diverso a questa soluzione può essere:

\begin{itemize}
	\item Individuazione delle caratteristiche e dei pattern di esecuzione delle istruzioni
		macchina generate dai programmi in HLL
	\item Semplificazione dell'architettura di base piuttosto che la sua complicazione
\end{itemize}

\subsection{RISC}%
\label{sub:risc}

Il processo di semplificazione coinvolge:

\begin{itemize}
	\item Le operazioni eseguite,\\
		semplificare le funzionalità del processore e la sua interazione con la memoria
	\item operandi,\\
		tipo e frequenza d'uso degli operandi sono alla base dell'organizzazione
		della memoria e dei modi di indirizzamento
	\item Flusso dell'esecuzione,\\
		organizzazione della pipeline e del controllo
\end{itemize}
Per rendere possibile questa semplificazione è necessario analizzare le istruzioni macchina 
generate dai programmi HLL, e analizzare le misure dinamiche che si raccolgono con l'esecuzione
del programma e contano il numero di occorrenze di una certa proprietà o di una certa 
caratteristica.\\
Per esempio nei linguaggi ad alto livello si hanno molte occorenze delle istruzioni di 
assegnamento e delle istruzioni condizionali. Oltre alla frequenza di un'istruzione
è importante tenere in conto il tempo d'esecuzione di un'istruzione.

\pparagraph{Esito Ricerca}%
\label{par:esito_ricerca}
Il risultato della ricerca eseguita in particolare da Hennessy e Patterson negli anni '80 porta 
alla conclusione che la strategia migliore per supportare i linguaggi ad alto livello è di:

\begin{itemize}
	\item \bt{ NON } rendere le istruzioni macchina simili a quella di HLL
	\item \bt{ OTTIMIZZAZIONE } delle performance e dei pattern più usati e 
		più time-consuming
	\item \bt{ ampio numero di registri } e il compilatore li utilizza in maniera 
		ottimizzzata
	\item \bt{ pipeline } accuratamente progettata
	\item \bt{ set di istruzioni semplificato, RISC } ed efficientemente implementato
\end{itemize}

\pparagraph{Uso dei regsitri}%
\label{par:uso_dei_regsitri}
Un registro è una memoria interna alla CPU ad accesso molto rapido ( + veloce della cache ), 
quindi hanno indirizzi più brevi di quelli della cache e della memoria principale,
è importante che gli \tit{ operandi } utilizzati siano conservati più a lungo nei registri
cosicchè da ridurre i trasferimenti memoria-registro.

\begin{itemize}
	\item \bt{ Hardware },\\
		aumenta il numero di registri,\\
		più variabili sono mantenute per più tempo
	\item \bt{ Software },\\
		il compilatore massimizza l'uso dei regsitri,\\
		le variabili più usate per ogni intervallo di tempo sono allocate nei registri,\\
		richiede una sofisticata analisi dell'utilizzo dei programmi
\end{itemize}
Per poter utilizzare i molti registri general purpose un'idea è quella di suddividere i registri
in molti piccoli gruppi ( finestre ) e per ogni procedura viene utilizzata un gruppo diverso.\\
Ogni gruppo è composto da:
\begin{itemize}
	\item Registro parametri,\\
		contiene i parametri che vengono passati quando la procedura viene chiamata
		e contiene il valore da restituire al chiamante al termine della procedura
	\item Registri locali,\\
		memorizza il contenuto delle variabili locali
	\item Registri temporanei,\\
		Scambia parametri e il valore di ritorno con un'eventuale procedura chiamata,\\
		molto spesso il registro temporaneo di una procedura \tit{ i } è il registro
		dei parametri della procedura successiva \tit{ i + 1 } a livello fisico, quindi
		non c'è nemmeno il bisogno di trasferire i dati
\end{itemize}

\pparagraph{Buffer Circolare}%
\label{par:buffer_circolare}

I registri sono spesso organizzati in un regitro circolare, in esso è presente il \bt{ CWP }, 
current window pointer, come suggerisce il nome esso indica la finestra corrente,\\
mentre il \bt{ SWP }, saved window pointer salva l'indrizzo della finestra in cui si deve 
ritornare al termine della procedura in corso.

\pparagraph{Variabili Globali}%
\label{par:variabili_globali}
Sono accessibili da qualunque procedura e da più di esse. Il compilatore
le allocca in memoria, questa cosa è però poco efficiente in quanto vengono usate spesso 
e l'utilizzo della memoria è un'operazione molto onerosa. La \bt{ soluzione } a questo problema
è quello di usare un \bt{ gruppo di registri ad hoc } che sono disponibili a tutte le procedure.

\pparagraph{Otimizzazione dei registri}%
\label{par:otimizzazione_dei_registri}
Lo scopo di quest'operazione è quella di trovare gli operandi il più possibile nei registri
e minimizzare le operazioni di \tit{ load/store }. L'implementazione \tit{ software } avviene
attraverso l'ottimizzazione del compilatore e mediante l'utilizzo di \bt{ registri simbolici }.\\
Ogni variabile viene mappata ad un registro reale e \tit{ se } due variabili vengono utilizzate
in momenti diversi possono essere mappate sullo \tit{ stesso registro }, il che può rendere il
numero dei regsitri quasi infinito.\\ 
Se il numero dei registri non è sufficiente per contenere \tit{ tutte  } le variabili esse
vengono memorizzate nella \tit{ memoria principale }.\\
Il numero di registri che vengono generalmente utilizzati nell'architettura \tit{ RISC } sono
fra i 32 e i 64.

\subsection{CISC}%
\label{sub:cisc}
Il tipo di architettura \bt{ CISC } \tit{ Complex Instruction Set Computer } a differenza 
dell'architettura RISC ha un'\tit{ampio} insieme di istruzioni, e ha istruzioni 
\bt{ più} complesse al fine di \tit{ semplificare } il lavoro del compilatore e migliorarne le
performance.\\
Tuttavia, non semplifica le istruzioni ma le rende più complesse e più simili ai linguaggi ad
alto livello, inoltre con set di istruzioni più complesso è difficile \tit{ ottimizzare il 
codice macchina} per ridurlo e riorganizzarlo.\\
Le istruzioni più complesse possono essere eseguite più \tit{ velocemente } \bt{ ma } al costo di

\begin{itemize}
	\item unità di controllo più complessa
	\item controllo microprogrammato necessita più spazio
	\item rallentamento dell'esecuzione delle istruioni più semplici, che rimangono
		\tit{ le più frequenti }
\end{itemize}

\subsection{Confronto fra CISC e RISC}%
\label{sub:confronto_fra_cisc_e_risc}

\paragraph{Istruzioni per ciclo di clock} \mbox{} \\%
\label{par:istruzinoi_per_ciclo_di_clock}

\bt{ RISC }: il ciclo esecutivo di quest'architettura dura un solo machine cycle, 
\tit{ se la pipeline è piena  } si termina un'istruione ad \bt{ ogni } ciclo di clock

\bt{ CISC }: le istruzioni di questo tipo impiegano più di un ciclo di clock per essere 
terminate.

\paragraph{Memorie usate per le operazioni} \mbox{} \\%
\label{par:memorie_usate_per_le_operazioni}

\bt{ RISC }: sono tutte fra registri tranne che per la \bt{ load/store } che sono fra registri e 
memoria.

\bt{ CISC }: hanno anche operazioni \tit{ memory-memory } e \tit{ register-memory }. Dato che 
vengono spesso utilizzati \tit{ scalari locali } aumentando e/o otttimizzando i registri
si ha un incremento delle prestazioni.

\paragraph{Modi di indirizzamento} \mbox{} \\%
\label{par:modi_di_indirizzamento}

\bt{ RISC }: si usano pochi e semplici modi di indirizzamento ( si semplifica l'istruzione ) 

\bt{ CISC }: si utilizzano molti modi di indirizzamento e alcuni complessi

\paragraph{Caratteristiche architetturali} \mbox{} \\%
\label{par:caratteristiche_architetturali}

\bt{ RISC: } pochi e semplici formati \tit{ fissi } per le istruzioni, decodifica opcode e 
accesso ai registri può essere simultaneo

\paragraph{Verdetto} \mbox{} \\%
\label{par:verdetto}
Tuttavia non si può notare quale architettura sia la \tit{ migliore } ma ciò dipende dai campi
applicativi in cui queste vengnono utilizzate, è difficile capire quanta influenza viene
data dal \tit{ compilatore },\\
( per esempio un buon compilatore CISC può rendere quest'architettura
migliore nel confronto se si ha uno scarso compilatore RISC ).\\
La maggior parte dei confronti eseguiti sono stati fatti su prototipi semplificati 
e non su macchine ad uso commerciale. 
Al giorno d'oggi alcune architetture utilizzano aspetti caratteristici delle
altre, per esempio architetture RISC con elementi CISC o viceversa.\\
Altre componenti cominciano a dover essere tenute in considerazione come:

\begin{itemize}
	\item GPU, graphic processing unit
	\item TPU, tensore processing unit, reti neurali e processori per machine learning
\end{itemize}

\subsection{Banco registri vs Cache}%
\label{sub:banco_registri_vs_cache}

\begin{itemize}
	\item Banco Registri,
		\begin{itemize}
			\item contiene \bt{ tutti } gli scalari locali
			\item variabili individuabili
			\item variabili globabli assegnate a registri specifici
			\item save/restore basato sulla profondità di annidamento
			\item indirizzamento a registro
		\end{itemize}
	\item Cache,
		\begin{itemize}
			\item \tit{ solo } gli scalari usati di recente
			\item blocchi di memoria
			\item \tit{ solo } le variabili globali usate di recente
			\item save/restore basato sull'algoritmo di sostituzione della cache
			\item indirizzamento a memoria
		\end{itemize}
\end{itemize}
Per riferirsi agli scalari locali i registri sono più veloci della cache.


\section{MIPS}%
\label{sec:mips}
MIPS = microprocessor without interlocked pipeline stages,\\
Questa architettura fu progettata da Hennesy e Patterson con lo scopo di 
implementare una \bt{pipeline efficiente}.\\
Tutte le istruzioni sono a \tit{ 32 bit }, le operazioni avvengono fra
\tit{ registri }, le uniche operazioni sulla memoria sono \tit{ load e store } e 
servono per trasferire dati fra la memoria e i regsitri. I dati che vengono caricati
sui registri possono essere sottoforma di: \tit{ byte, mezze parole, parole }

\pparagraph{Modi di indirizzamento}%
\label{ppar:Modi di indirizzamento}

\begin{itemize}
	\item Immediato	
	\item Displacement
	\item Alternative
		\begin{itemize}
			\item Indiretta registro ( displacement a 0 )
			\item Assoluta ( Registro 0 come base ) 
		\end{itemize}
\end{itemize}

\pparagraph{Formato Istruzioni}%
\label{ppar:Formato Istruzioni}
Esistono 3 tipi di formati nell'architettura MIPS:

\begin{itemize}
	\item Formato R(register):
		\begin{itemize}
			\item codop, 6bit,\\
				sono istruzioni aritmetico-logiche
			\item rs, 5 bit,\\
				registro con il primo argomento
			\item rt, 5 bit,\\
				registro con il secondo argomento
			\item rd, 5 bit,\\
				registro destinazione che riceve il risultato
			\item shamt, 5 bit,\\
				shift amount, nelle istruzioni di shift dice di quanti bit 
				fare lo shift
			\item funct, 6 bit,\\
				identifica la variante operativa
		\end{itemize}
	\item Formato I(mmediato):
		\begin{itemize}
			\item codop, 6 bit,\\
				sono le istruzioni di load/store, aritmetiche immediate 
				e salto condizionato
			\item rs, 5 bit,\\
				primo argomento
			\item rt, 5 bit,\\
				secondo argomento
			\item address/const, 16 bit,\\
				spiazzamento o costante
		\end{itemize}	
	\item Formato J(ump):
		\begin{itemize}
			\item codop, 6 bit,\\
				salto incondizionato
			\item target address, 26 bit
		\end{itemize}
\end{itemize}

\pparagraph{Ciclo esecutivo MIPS}%
\label{ppar:Ciclo esecutivo MIPS}
Il ciclo esecutivo si suddivide in 5 fasi:


\begin{itemize}
	\item IF, instruction fetch
	\item ID, instruction decode
	\item EX, execution,\\
		tutte le istruzioni usano l'alu fuorchè quella di salto incondizionato
	\item MEM, Memory access/ branch completion
	\item WB, write back, scrittura del risultato nei registri.
\end{itemize}
In un ciclo di clock si esegue una fase, un'istruzione viene eseguita in 5 cicli di clock 
( a regime ).\\
Ci sono dei registri fra ogni fase della pipeline, ( per esempio fra la fase ID e la EX ) e 
servono per memorizzare i dati.\\
Nella pipeline del MIPS è possibile individuare qualsiasi dipendenza dai dati nella fase di 
decodifica delle istruzioni e inoltre in un ciclo di clock si può scrivere ( prima metà ) e
leggere ( seconda metà ) uno stesso registro.

\pparagraph{Note per gli esercizi}%
\label{ppar:Note per gli esercizi}
Le operazioni di aritmetica \tit{ ADD, SUB } possono trasmettere un dato al termine della fase
\bt{ EX }.\\
La \tit{ load/store }, dato che devono accedere alla memoria possono trasmettere un dato al 
termine della fase MEM

\section{Processori Multi-Core}%
\label{sec:processori_multi_core}


\end{document}
